c2 Statistical Learning
=======================

**2.1 What Is Statistical Learning?**

In order to motivate our study of statistical learning, we begin with a simple example. Suppose that we are statistical consultants 
hired by a client to provide advice on how to improve sales of a particular product. The Advertising data set consists of the sales of 
that product in 200 diﬀerent markets, along with advertising budgets for the product in each of those markets for three diﬀerent 
media: TV, radio, and newspaper. The data are displayed in Figure 2.1. It is not possible for our client to directly increase sales of 
the product. On the other hand, they can control the advertising expenditure in each of the three media. Therefore, if we determine 
that there is an association between advertising and sales, then we can instruct our client to adjust advertising budgets, thereby 
indirectly increasing sales.

In other words, our goal is to develop an accurate model that can be used to predict sales on the basis of the three media budgets.

In this setting, the advertising budgets are input variables while sales input is an output variable. The input variables are 
typically denoted using the variable symbol X, with a subscript to distinguish them. So X 1 might be the TV output variable budget, X 
2 the radio budget, and X 3 the newspaper budget. The inputs go by diﬀerent names, such as predictors, independent variables, 
features, predictor or sometimes just variables. The output variable—in this case, sales—is independent often called the response or 
dependent variable, and is typically denoted variable using the symbol Y . Throughout this book, we will use all of these terms 
feature interchangeably.

**FIGURE 2.1.** The Advertising data set. The plot displays sales, in thousands of units, as a function of TV, radio, and newspaper 
budgets, in thousands of dollars, for 200 di ﬀ erent markets. In each plot we show the simple least squares ﬁt of sales to that 
variable, as described in Chapter 3. In other words, each blue line represents a simple model that can be used to predict sales using 
TV, radio, and newspaper, respectively.

More generally, suppose that we observe a quantitative response Y and p diﬀerent predictors,:math:`X_1 , X_2 ,..., X_p`. We 
assume that 
there is some relationship between Y and :math:`X = (X_1 , X_2 , ..., X_p )`, which can be written in the very general form
.. math::

   Y = f(X) + \epsilon

(2.1)

Here f is some ﬁxed but unknown function of:math:`X_1 ,..., X_p`, and  is a random error term, which is independent of X and 
has mean 
zero. In this formulation, f represents the systematic information that X provides about Y .

As another example, consider the left-hand panel of Figure 2.2, a plot of income versus years of education for 30 individuals in the 
Income data set. The plot suggests that one might be able to predict income using years of education. However, the function f that 
connects the input variable to the output variable is in general unknown. In this situation one must estimate f based on the observed 
points. Since Income is a simulated data set, f is known and is shown by the blue curve in the right-hand panel of Figure 2.2. The 
vertical lines represent the error terms . We note that some of the 30 observations lie above the blue curve and some lie below it; 
overall, the errors have approximately mean zero.

In general, the function f may involve more than one input variable. In Figure 2.3 we plot income as a function of years of education 
and seniority. Here f is a two-dimensional surface that must be estimated based on the observed data.

FIGURE 2.2. The Income data set. Left: The red dots are the observed values of income (in tens of thousands of dollars) and years of 
education for 30 individuals. Right: The blue curve represents the true underlying relationship between income and years of education, 
which is generally unknown (but is known in this case because the data were simulated). The black lines represent the error associated 
with each observation. Note that some errors are positive (if an observation lies above the blue curve) and some are negative (if an 
observation lies below the curve). Overall, these errors have approximately mean zero.

In essence, statistical learning refers to a set of approaches for estimating f. In this chapter we outline some of the key 
theoretical concepts that arise in estimating f, as well as tools for evaluating the estimates obtained.

**2.1.1 Why Estimate f?**

There are two main reasons that we may wish to estimate f: prediction and inference. We discuss each in turn.

**Prediction**

In many situations, a set of inputs X are readily available, but the output Y cannot be easily obtained. In this setting, since the 
error term averages to zero, we can predict Y using

.. math::

   \hat{Y} = \hat{f}(X),

(2.2)

where :math:`\hat{f}` represents our estimate for f, and :math:`\hat{Y}` represents the resulting prediction for Y . In this 
setting, :math:`\hat{f}` is often treated as 
a black box, in the sense that one is not typically concerned with the exact form of :math:`\hat{f}`, provided that it yields 
accurate predictions 
for Y .

FIGURE 2.3. The plot displays income as a function of years of education and seniority in the Income data set. The blue surface 
represents the true underlying relationship between income and years of education and seniority, which is known since the data are 
simulated. The red dots indicate the observed values of these quantities for 30 individuals.

As an example, suppose that :math:`X_1 ,..., X_p` are characteristics of a patient’s blood sample that can be easily measured 
in a lab, 
and Y is a variable encoding the patient’s risk for a severe adverse reaction to a particular drug. It is natural to seek to predict Y 
using X, since we can then avoid giving the drug in question to patients who are at high risk of an adverse reaction—that is, patients 
for whom the estimate of Y is high.

The accuracy of :math:`\hat{Y}` as a prediction for Y depends on two quantities, which we will call the reducible error and the 
irreducible error. 
In general, :math:`\hat{f}` will not be a perfect estimate for f, and this inaccuracy will introduce
reducible error irreducible error
some error. This error is reducible because we can potentially improve the accuracy of :math:`\hat{f}` by using the most appropriate 
statistical 
learning technique to estimate f. However, even if it were possible to form a perfect estimate for f, so that our estimated response 
took the form :math:`\hat{Y} = f(X)`, our prediction would still have some error in it! This is because Y is also a function of 
:math:`\epsilon`, 
which, by 
deﬁnition, cannot be predicted using X. Therefore, variability associated with  also aﬀects the accuracy of our predictions. This is 
known as the irreducible error, because no matter how well we estimate f, we cannot reduce the error introduced by :math:`\epsilon`.

Why is the irreducible error larger than zero? The quantity  may contain unmeasured variables that are useful in predicting Y : since 
we don’t measure them, f cannot use them for its prediction. The quantity  may also contain unmeasurable variation. For example, the 
risk of an adverse reaction might vary for a given patient on a given day, depending on
manufacturing variation in the drug itself or the patient’s general feeling of well-being on that day.

Consider a given estimate :math:`\hat{f}`  and a set of predictors X, which yields the prediction :math:`\hat{Y} = \hat{f}(X)`. Assume 
for a moment that both :math:`\hat{f}`  
and X are ﬁxed. Then, it is easy to show that

.. math::

   E(Y −\hat{ } ^ 2 = E[f(X)  \epsilon+   \hat{f}(X)]^2
 
   \underbrace{[f(x)-\hat{f}(x)]^^2}_{Reducible}+ \underbrace{Var(\epsilon)}_{Irreducible}


(2.3)

where :math:`E(Y −\hat{ })^2` represents the average, or expected value, of the squared diﬀerence between the predicted and 
actual value of Y 
, and :math:`Var(\epsilon)` represents the variance associated with the error term :math:`\epsilon`.

The focus of this book is on techniques for estimating f with the aim of minimizing the reducible error. It is important to keep in 
mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for Y . This bound is almost 
always unknown in practice.

**Inference**

We are often interested in understanding the way that Y is aﬀected as:math:`X_1 ,...,X_p` change. In this situation we wish 
to estimate 
f, but our goal is not necessarily to make predictions for Y . We instead want to understand the relationship between X and Y , or 
more speciﬁcally, to understand how Y changes as a function of:math:`X_1 ,..., X_p`. Now :math:`\hat{f}` cannot be treated as a 
black box, because 
we need to know its exact form. In this setting, one may be interested in answering the following questions:

• Which predictors are associated with the response? It is often the case that only a small fraction of the available predictors are 
substantially associated with Y . Identifying the few important predictors among a large set of possible variables can be extremely 
useful, depending on the application.

• What is the relationship between the response and each predictor? Some predictors may have a positive relationship with Y , in the 
sense that increasing the predictor is associated with increasing values of Y . Other predictors may have the opposite relationship. 
Depending on the complexity of f, the relationship between the response and a given predictor may also depend on the values of the 
other predictors.

• Can the relationship between Y and each predictor be adequately summarized using a linear equation, or is the relationship more 
complicated? Historically, most methods for estimating f have taken a linear form. In some situations, such an assumption is 
reasonable or even desirable. But often the true relationship is more complicated, in which case a linear model may not provide an 
accurate representation of the relationship between the input and output variables.

In this book, we will see a number of examples that fall into the prediction setting, the inference setting, or a combination of the 
two.

For instance, consider a company that is interested in conducting a direct-marketing campaign. The goal is to identify individuals who 
will respond positively to a mailing, based on observations of demographic variables measured on each individual. In this case, the 
demographic variables serve as predictors, and response to the marketing campaign (either positive or negative) serves as the outcome. 
The company is not interested in obtaining a deep understanding of the relationships between each individual predictor and the 
response; instead, the company simply wants an accurate model to predict the response using the predictors. This is an example of 
modeling for prediction.

In contrast, consider the Advertising data illustrated in Figure 2.1. One may be interested in answering questions such as:

– Which media contribute to sales?

– Which media generate the biggest boost in sales? or

– How much increase in sales is associated with a given increase in TV advertising?

This situation falls into the inference paradigm. Another example involves modeling the brand of a product that a customer might 
purchase based on variables such as price, store location, discount levels, competition price, and so forth. In this situation one 
might really be most interested in how each of the individual variables aﬀects the probability of purchase. For instance, what e ﬀ 
ect will changing the price of a product have on sales? This is an example of modeling for inference.

Finally, some modeling could be conducted both for prediction and inference. For example, in a real estate setting, one may seek to 
relate values of homes to inputs such as crime rate, zoning, distance from a river, air quality, schools, income level of community, 
size of houses, and so forth. In this case one might be interested in how the individual input variables aﬀect the prices—that is, 
how much extra will a house be worth if it has a view of the river? This is an inference problem. Alternatively, one may simply be 
interested in predicting the value of a home given its characteristics: is this house under- or over-valued? This is a prediction 
problem.

Depending on whether our ultimate goal is prediction, inference, or a combination of the two, diﬀerent methods for estimating f may 
be appropriate. For example, linear models allow for relatively simple and interpretable inference, but may not yield as accurate 
predictions as some other approaches. In contrast, some of the highly non-linear approaches that we discuss in the later chapters of 
this book can potentially provide quite accurate predictions for Y , but this comes at the expense of a less interpretable model for 
which inference is more challenging.

**2.1.2 How Do We Estimate f?**

Throughout this book, we explore many linear and non-linear approaches for estimating f. However, these methods generally share 
certain characteristics. We provide an overview of these shared characteristics in this section. We will always assume that we have 
observed a set of n diﬀerent data points. For example in Figure 2.2 we observed n = 30 data points. These observations are called the 
training data because we will use these observations to train, or teach, our method how to estimate f. Let xij  represent the value of 
the jth predictor, or input, for observation i, where i = 1, 2, . . ., n and j = 1, 2, . . ., p. Correspondingly, let yi represent 
the response variable for the ith observation. Then our training data consist of { (x1 , y1 ), (x2 , y2 ),..., (xn , yn ) } 
where :math:`x_i = (x_{i1} , x_{i2} ,..., x_{ip} )^T` . Our goal is to apply a statistical learning method to the training data 
in order to 
estimate the unknown function f. In other words, we want to ﬁnd a function f ˆ such that Y ≈ ˆ f(X) for any observation (X, Y ). 
Broadly speaking, most statistical learning methods for this task can be characterized as either parametric or non-parametric. We now 
brieﬂy discuss these two types of approaches.

Parametric Methods

Parametric methods involve a two-step model-based approach.

1. First, we make an assumption about the functional form, or shape, of f. For example, one very simple assumption is that f is linear 
in X: (2.4)

f(X) = β 0 + β 1 X 1 + β 2 X 2 + . . . + β p X p .

This is a linear model, which will be discussed extensively in Chapter 3. Once we have assumed that f is linear, the problem of 
estimating f is greatly simpliﬁed. Instead of having to estimate an entirely arbitrary p-dimensional function f(X), one only needs to 
estimate

training data

parametric nonparametric

the p + 1 coeﬃcients β 0 , β 1 , . . . , β p .

2. After a model has been selected, we need a procedure that uses the training data to ﬁt or train the model. In the case of the 
linear model (2.4), we need to estimate the parameters β 0 , β 1 , . . . , β p . That is, we want to ﬁnd values of these parameters 
such that

Y ≈ β 0 + β 1 X 1 + β 2 X 2 + ... + β p Xp .

The most common approach to ﬁtting the model (2.4) is referred to as (ordinary) least squares, which we discuss in Chapter 3. 
However, least squares is one of many possible ways way to ﬁt the linear model. In Chapter 6, we discuss other approaches for 
estimating the parameters in (2.4).

The model-based approach just described is referred to as parametric; it reduces the problem of estimating f down to one of estimating 
a set of

FIGURE 2.4. A linear model ﬁt by least squares to the Income data from Figure 2.3. The observations are shown in red, and the yellow 
plane indicates the least squares ﬁt to the data.

parameters. Assuming a parametric form for f simpliﬁes the problem of estimating f because it is generally much easier to estimate a 
set of parameters, such as β 0 , β 1 , . . . , β p in the linear model (2.4), than it is to ﬁt an entirely arbitrary function f. The 
potential disadvantage of a parametric approach is that the model we choose will usually not match the true unknown form of f. If the 
chosen model is too far from the true f, then our estimate will be poor. We can try to address this problem by choosing ﬂexible 
models that can ﬁt many diﬀerent possible functional forms for f. But in general, ﬁtting a more ﬂexible model requires estimating 
a greater number of parameters. These more complex models can lead to a phenomenon known as overﬁtting the data, which essentially 
means they follow the errors, or noise, too closely. These issues are discussed throughout this book.

Figure 2.4 shows an example of the parametric approach applied to the Income data from Figure 2.3. We have ﬁt a linear model of the 
form

+ β 1 × education + β 2 × seniority.

≈ β0 

income

Since we have assumed a linear relationship between the response and the two predictors, the entire ﬁtting problem reduces to 
estimating β 0 , β 1 , and β 2 , which we do using least squares linear regression. Comparing Figure 2.3 to Figure 2.4, we can see 
that the linear ﬁt given in Figure 2.4 is not quite right: the true f has some curvature that is not captured in the linear ﬁt. 
However, the linear ﬁt still appears to do a reasonable job of capturing the positive relationship between years of education and 
income, as well as the

FIGURE 2.5. A smooth thin-plate spline ﬁt to the Income data from Figure 2.3 is shown in yellow; the observations are displayed in 
red. Splines are discussed in Chapter 7.

slightly less positive relationship between seniority and income. It may be that with such a small number of observations, this is the 
best we can do.

Non-parametric Methods

Non-parametric methods do not make explicit assumptions about the functional form of f. Instead they seek an estimate of f that gets 
as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric 
approaches: by avoiding the assumption of a particular functional form for f, they have the potential to accurately ﬁt a wider range 
of possible shapes for f. Any parametric approach brings with it the possibility that the functional form used to estimate f is very 
diﬀerent from the true f, in which case the resulting model will not ﬁt the data well. In contrast, non-parametric approaches 
completely avoid this danger, since essentially no assumption about the form of f is made. But non-parametric approaches do suﬀer 
from a major disadvantage: since they do not reduce the problem of estimating f to a small number of parameters, a very large number 
of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for 
f.

An example of a non-parametric approach to ﬁtting the Income data is shown in Figure 2.5. A thin-plate spline is used to estimate f. 
This approach does not impose any pre-speciﬁed model on f. It instead attempts to produce an estimate for f that is as close as 
possible to the observed data, subject to the ﬁt—that is, the yellow surface in Figure 2.5—being

FIGURE 2.6. A rough thin-plate spline ﬁt to the Income data from Figure 2.3. This ﬁt makes zero errors on the training data.

smooth. In this case, the non-parametric ﬁt has produced a remarkably accurate estimate of the true f shown in Figure 2.3. In order 
to ﬁt a thin-plate spline, the data analyst must select a level of smoothness. Figure 2.6 shows the same thin-plate spline ﬁt using 
a lower level of smoothness, allowing for a rougher ﬁt. The resulting estimate ﬁts the observed data perfectly! However, the spline 
ﬁt shown in Figure 2.6 is far more variable than the true function f, from Figure 2.3. This is an example of overﬁtting the data, 
which we discussed previously. It is an undesirable situation because the ﬁt obtained will not yield accurate estimates of the 
response on new observations that were not part of the original training data set. We discuss methods for choosing the correct amount 
of smoothness in Chapter 5. Splines are discussed in Chapter 7.

As we have seen, there are advantages and disadvantages to parametric and non-parametric methods for statistical learning. We explore 
both types of methods throughout this book.

2.1.3 The Trade-O ﬀ Between Prediction Accuracy and Model Interpretability

Of the many methods that we examine in this book, some are less ﬂexible, or more restrictive, in the sense that they can produce just 
a relatively small range of shapes to estimate f. For example, linear regression is a relatively inﬂexible approach, because it can 
only generate linear functions such as the lines shown in Figure 2.1 or the plane shown in Figure 2.3.

FIGURE 2.7. A representation of the tradeo ﬀ between ﬂexibility and interpretability, using di ﬀ erent statistical learning 
methods. In general, as the ﬂexibility of a method increases, its interpretability decreases.

Other methods, such as the thin plate splines shown in Figures 2.5 and 2.6, are considerably more ﬂexible because they can generate a 
much wider range of possible shapes to estimate f.

One might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very ﬂexible 
approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inference, then 
restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since 
it will be quite easy to understand the relationship between Y and X 1 , X 2 , . . . , X p . In contrast, very ﬂexible approaches, 
such as the splines discussed in Chapter 7 and displayed in Figures 2.5 and 2.6, and the boosting methods discussed in Chapter 8, can 
lead to such complicated estimates of f that it is diﬃcult to understand how any individual predictor is associated with the 
response.

Figure 2.7 provides an illustration of the trade-oﬀ between ﬂexibility and interpretability for some of the methods that we cover in 
this book. Least squares linear regression, discussed in Chapter 3, is relatively inﬂexible but is quite interpretable. The lasso, 
discussed in Chapter 6, relies upon the linear model (2.4) but uses an alternative ﬁtting procedure for estimating the coeﬃcients β 
0 , β 1 , . . . , β p . The new procedure is more restrictive in estimating the coeﬃcients, and sets a number of them to exactly 
zero. Hence in this sense the lasso is a less ﬂexible approach than linear regression. It is also more interpretable than linear 
regression, because in the ﬁnal model the response variable will only be related to a small subset of the predictors—namely, those 
with nonzero coeﬃcient estimates. Generalized

additive models (GAMs), discussed in Chapter 7, instead extend the linear model (2.4) to allow for certain non-linear relationships. 
Consequently, GAMs are more ﬂexible than linear regression. They are also somewhat less interpretable than linear regression, because 
the relationship between each predictor and the response is now modeled using a curve. Finally, fully non-linear methods such as 
bagging, boosting, and support vector machines with non-linear kernels, discussed in Chapters 8 and 9, are highly ﬂexible approaches 
that are harder to interpret.

We have established that when inference is the goal, there are clear advantages to using simple and relatively inﬂexible statistical 
learning methods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is 
simply not of interest. For instance, if we seek to develop an algorithm to predict the price of a stock, our sole requirement for the 
algorithm is that it predict accuratelyinterpretability is not a concern. In this setting, we might expect that it will be best to use 
the most ﬂexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a 
less ﬂexible method. This phenomenon, which may seem counterintuitive at ﬁrst glance, has to do with the potential for overﬁtting 
in highly ﬂexible methods. We saw an example of overﬁtting in Figure 2.6. We will discuss this very important concept further in 
Section 2.2 and throughout this book.

2.1.4 Supervised Versus Unsupervised Learning

Most statistical learning problems fall into one of two categories: supervised or unsupervised. The examples that we have discussed so 
far in this chapter all fall into the supervised learning domain. For each observation of the predictor measurement(s) x i , i = 1, . 
. . , n there is an associated response measurement y i . We wish to ﬁt a model that relates the response to the predictors, with the 
aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the 
response and the predictors (inference). Many classical statistical learning methods such as linear regression and logistic regression 
(Chapter 4), as well as more modern approaches such as GAM, boosting, and support vector machines, operate in the supervised learning 
domain. The vast majority of this book is devoted to this setting.

In contrast, unsupervised learning describes the somewhat more challenging situation in which for every observation i = 1, . . . , n, 
we observe a vector of measurements x i but no associated response y i . It is not possible to ﬁt a linear regression model, since 
there is no response variable to predict. In this setting, we are in some sense working blind; the situation is referred to as 
unsupervised because we lack a response variable that can supervise our analysis. What sort of statistical analysis is

FIGURE 2.8. A clustering data set involving three groups. Each group is shown using a di ﬀ erent colored symbol. Left: The three 
groups are well-separated. In this setting, a clustering approach should successfully identify the three groups. Right: There is some 
overlap among the groups. Now the clustering task is more challenging.

possible? We can seek to understand the relationships between the variables or between the observations. One statistical learning tool 
that we may use in this setting is cluster analysis, or clustering. The goal of cluster analysis is to ascertain, on the basis of x 1 
, . . . , x n , whether the observations fall into relatively distinct groups. For example, in a market segmentation study we might 
observe multiple characteristics (variables) for potential customers, such as zip code, family income, and shopping habits. We might 
believe that the customers fall into diﬀerent groups, such as big spenders versus low spenders. If the information about each 
customer’s spending patterns were available, then a supervised analysis would be possible. However, this information is not 
available—that is, we do not know whether each potential customer is a big spender or not. In this setting, we can try to cluster the 
customers on the basis of the variables measured, in order to identify distinct groups of potential customers. Identifying such groups 
can be of interest because it might be that the groups diﬀer with respect to some property of interest, such as spending habits.

Figure 2.8 provides a simple illustration of the clustering problem. We have plotted 150 observations with measurements on two 
variables, X1  and X 2 . Each observation corresponds to one of three distinct groups. For illustrative purposes, we have plotted the 
members of each group using diﬀerent colors and symbols. However, in practice the group memberships are unknown, and the goal is to 
determine the group to which each observation belongs. In the left-hand panel of Figure 2.8, this is a relatively easy task because 
the groups are well-separated. In contrast, the right-hand panel illustrates a more challenging problem in which there is some overlap

between the groups. A clustering method could not be expected to assign all of the overlapping points to their correct group (blue, 
green, or orange).

In the examples shown in Figure 2.8, there are only two variables, and so one can simply visually inspect the scatterplots of the 
observations in order to identify clusters. However, in practice, we often encounter data sets that contain many more than two 
variables. In this case, we cannot easily plot the observations. For instance, if there are p variables in our data set, then p(p − 
1)/2 distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, 
automated clustering methods are important. We discuss clustering and other unsupervised learning approaches in Chapter 10.

Many problems fall naturally into the supervised or unsupervised learning paradigms. However, sometimes the question of whether an 
analysis should be considered supervised or unsupervised is less clear-cut. For instance, suppose that we have a set of n 
observations. For m of the observations, where m < n, we have both predictor measurements and a response measurement. For the 
remaining n − m observations, we have predictor measurements but no response measurement. Such a scenario can arise if the predictors 
can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as a 
semi-supervised learning problem. In this setting, we wish to use a statistical learning method that can incorporate the m 
observations for which response measurements are available as well as the n − m observations for which they are not. Although this is 
an interesting topic, it is beyond the scope of this book.

2.1.5 Regression Versus Classiﬁcation Problems

Variables can be characterized as either quantitative or qualitative (also known as categorical). Quantitative variables take on 
numerical values. Examples include a person’s age, height, or income, the value of a house, and the price of a stock. In contrast, 
qualitative variables take on values in one of K diﬀerent classes, or categories. Examples of qualitative variables include a 
person’s gender (male or female), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), 
or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lymphoblastic Leukemia, or No Leukemia). We tend to refer to problems with a 
quantitative response as regression problems, while those involving a qualitative response are often referred to as classiﬁcation 
problems. However, the distinction is not always that crisp. Least squares linear regression (Chapter 3) is used with a quantitative 
response, whereas logistic regression (Chapter 4) is typically used with a qualitative (two-class, or binary) response. As such it is 
often used as a classiﬁcation method. But since it estimates class probabilities, it can be thought of as a regression

method as well. Some statistical methods, such as K-nearest neighbors (Chapters 2 and 4) and boosting (Chapter 8), can be used in the 
case of either quantitative or qualitative responses.

We tend to select statistical learning methods on the basis of whether the response is quantitative or qualitative; i.e. we might use 
linear regression when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or 
quantitative is generally considered less important. Most of the statistical learning methods discussed in this book can be applied 
regardless of the predictor variable type, provided that any qualitative predictors are properly coded before the analysis is 
performed. This is discussed in Chapter 3.

2.2 Assessing Model Accuracy

One of the key aims of this book is to introduce the reader to a wide range of statistical learning methods that extend far beyond the 
standard linear regression approach. Why is it necessary to introduce so many diﬀerent statistical learning approaches, rather than 
just a single best method? There is no free lunch in statistics: no one method dominates all others over all possible data sets. On a 
particular data set, one speciﬁc method may work best, but some other method may work better on a similar but diﬀerent data set. 
Hence it is an important task to decide for any given set of data which method produces the best results. Selecting the best approach 
can be one of the most challenging parts of performing statistical learning in practice.

In this section, we discuss some of the most important concepts that arise in selecting a statistical learning procedure for a 
speciﬁc data set. As the book progresses, we will explain how the concepts presented here can be applied in practice.

2.2.1 Measuring the Quality of Fit

In order to evaluate the performance of a statistical learning method on a given data set, we need some way to measure how well its 
predictions actually match the observed data. That is, we need to quantify the extent to which the predicted response value for a 
given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure 
is the mean squared error (MSE), given by

n 1 ˆ f(xi  MSE = n ∑ (y i − )) 2 , i=1

(2.5)

where ) is the prediction that will be small if the predicted responses are very close to the true responses, and will be large if for 
some of the observations, the predicted and true responses diﬀer substantially.

The MSE in (2.5) is computed using the training data that was used to ﬁt the model, and so should more accurately be referred to as 
the training MSE. But in general, we do not really care how well the method works on the training data. Rather, we are interested in 
the accuracy of the predictions that we obtain when we apply our method to previously unseen test data. Why is this what we care 
about? Suppose that we are interested in developing an algorithm to predict a stock’s price based on previous stock returns. We can 
train the method using stock returns from the past 6 months. But we don’t really care how well our method predicts last week’s stock 
price. We instead care about how well it will predict tomorrow’s price or next month’s price. On a similar note, suppose that we have 
clinical measurements (e.g. weight, blood pressure, height, age, family history of disease) for a number of patients, as well as 
information about whether each patient has diabetes. We can use these patients to train a statistical learning method to predict risk 
of diabetes based on clinical measurements. In practice, we want this method to accurately predict diabetes risk for future patients 
based on their clinical measurements. We are not very interested in whether or not the method accurately predicts diabetes risk for 
patients used to train the model, since we already know which of those patients have diabetes.

To state it more mathematically, suppose that we ﬁt our statistical learning method on our training observations { (x 1 , y 1 ), (x 2 
, y 2 ), . . . , (x n , y n ) } , and we obtain the estimate f. ˆ We can then compute ˆ f(x 1 ), ˆ f(x 2 ), . . . , ˆ f(x n ). If 
these are approximately equal to y 1 , y 2 , . . . , y n , then the training MSE given by (2.5) is small. However, we are really not 
interested in whether ˆ f(x i ) ≈ y i ; instead, we want to know whether ˆ f(x 0 ) is approximately equal to y 0 , where (x 0 , y 0 ) 
is a previously unseen test observation not used to train the statistical learning method. We want to choose the method that gives the 
lowest test MSE, as opposed to the lowest training MSE. In other words, if we had a large number of test observations, we could 
compute

Ave( ˆ f(x 0 ) − y 0 ) 2 ,

(2.6)

the average squared prediction error for these test observations (x 0 , y 0 ). We’d like to select the model for which the average of 
this quantity—the test MSE—is as small as possible.

How can we go about trying to select a method that minimizes the test MSE? In some settings, we may have a test data set 
available—that is, we may have access to a set of observations that were not used to train the statistical learning method. We can 
then simply evaluate (2.6) on the test observations, and select the learning method for which the test MSE is

FIGURE 2.9. Left: Data simulated from f, shown in black. Three estimates of f are shown: the linear regression line (orange curve), 
and two smoothing spline ﬁts (blue and green curves). Right: Training MSE (grey curve), test MSE (red curve), and minimum possible 
test MSE over all methods (dashed line). Squares represent the training and test MSEs for the three ﬁts shown in the left-hand panel.

2

5

10 Flexibility

20

Mean Squared

1.5

Error

0.0

0.5

1.0

2.0

2.5

smallest. But what if no test observations are available? In that case, one might imagine simply selecting a statistical learning 
method that minimizes the training MSE (2.5). This seems like it might be a sensible approach, since the training MSE and the test MSE 
appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method 
with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods 
speciﬁcally estimate coeﬃcients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, 
but the test MSE is often much larger.

Figure 2.9 illustrates this phenomenon on a simple example. In the left-hand panel of Figure 2.9, we have generated observations from 
(2.1) with the true f given by the black curve. The orange, blue and green curves illustrate three possible estimates for f obtained 
using methods with increasing levels of ﬂexibility. The orange line is the linear regression ﬁt, which is relatively inﬂexible. The 
blue and green curves were produced using smoothing splines, discussed in Chapter 7, with diﬀerent levels of smoothness. It is clear 
that as the level of ﬂexibility increases, the curves ﬁt the observed data more closely. The green curve is the most ﬂexible and 
matches the data very well; however, we observe that it ﬁts the true f (shown in black) poorly because it is too wiggly. By adjusting 
the level of ﬂexibility of the smoothing spline ﬁt, we can produce many diﬀerent ﬁts to this data.

We now move on to the right-hand panel of Figure 2.9. The grey curve displays the average training MSE as a function of ﬂexibility, 
or more formally the degrees of freedom, for a number of smoothing splines. The degrees of freedom is a quantity that summarizes the 
ﬂexibility of a curve; it is discussed more fully in Chapter 7. The orange, blue and green squares indicate the MSEs associated with 
the corresponding curves in the left-hand panel. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly 
curve—note that in Figure 2.9, linear regression is at the most restrictive end, with two degrees of freedom. The training MSE 
declines monotonically as ﬂexibility increases. In this example the true f is non-linear, and so the orange linear ﬁt is not 
ﬂexible enough to estimate f well. The green curve has the lowest training MSE of all three methods, since it corresponds to the most 
ﬂexible of the three curves ﬁt in the left-hand panel.

In this example, we know the true function f, and so we can also compute the test MSE over a very large test set, as a function of 
ﬂexibility. (Of course, in general f is unknown, so this will not be possible.) The test MSE is displayed using the red curve in the 
right-hand panel of Figure 2.9. As with the training MSE, the test MSE initially declines as the level of ﬂexibility increases. 
However, at some point the test MSE levels oﬀ and then starts to increase again. Consequently, the orange and green curves both have 
high test MSE. The blue curve minimizes the test MSE, which should not be surprising given that visually it appears to estimate f the 
best in the left-hand panel of Figure 2.9. The horizontal dashed line indicates Var(), the irreducible error in (2.3), which 
corresponds to the lowest achievable test MSE among all possible methods. Hence, the smoothing spline represented by the blue curve is 
close to optimal.

In the right-hand panel of Figure 2.9, as the ﬂexibility of the statistical learning method increases, we observe a monotone decrease 
in the training MSE and a U-shape in the test MSE. This is a fundamental property of statistical learning that holds regardless of the 
particular data set at hand and regardless of the statistical method being used. As model ﬂexibility increases, training MSE will 
decrease, but the test MSE may not. When a given method yields a small training MSE but a large test MSE, we are said to be 
overﬁtting the data. This happens because our statistical learning procedure is working too hard to ﬁnd patterns in the training 
data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function 
f. When we overﬁt the training data, the test MSE will be very large because the supposed patterns that the method found in the 
training data simply don’t exist in the test data. Note that regardless of whether or not overﬁtting has occurred, we almost always 
expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek 
to minimize the training MSE. Overﬁtting refers speciﬁcally to the case in which a less ﬂexible model would have yielded a smaller 
test MSE.

FIGURE 2.10. Details are as in Figure 2.9, using a di ﬀ erent true f that is much closer to linear. In this setting, linear 
regression provides a very good ﬁt to the data.

2

5

10 Flexibility

20

Mean Squared

1.5

Error

0.0

0.5

1.0

2.0

2.5

Figure 2.10 provides another example in which the true f is approximately linear. Again we observe that the training MSE decreases 
monotonically as the model ﬂexibility increases, and that there is a U-shape in the test MSE. However, because the truth is close to 
linear, the test MSE only decreases slightly before increasing again, so that the orange least squares ﬁt is substantially better 
than the highly ﬂexible green curve. Finally, Figure 2.11 displays an example in which f is highly non-linear. The training and test 
MSE curves still exhibit the same general patterns, but now there is a rapid decrease in both curves before the test MSE starts to 
increase slowly.

In practice, one can usually compute the training MSE with relative ease, but estimating test MSE is considerably more diﬃcult 
because usually no test data are available. As the previous three examples illustrate, the ﬂexibility level corresponding to the 
model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a variety of approaches that 
can be used in practice to estimate this minimum point. One important method is cross-validation (Chapter 5), which is a crossmethod 
for estimating test MSE using the training data. validation

2.2.2 The Bias-Variance Trade-O ﬀ

The U-shape observed in the test MSE curves (Figures 2.9–2.11) turns out to be the result of two competing properties of statistical 
learning methods. Though the mathematical proof is beyond the scope of this book, it is possible to show that the expected test MSE, 
for a given value x 0 , can

always be decomposed into the sum of three fundamental quantities: the variance of ˆ f(x 0 ), the squared bias of ˆ f(x 0 ) and the 
variance of the error terms . That is,

E − ˆ f(x 0 ) = Var( ˆ f(x 0 )) + [Bias( ˆ f(x 0 ))] 2 + Var(). y0  ( )2 

(2.7)

y0  − ) deﬁnes the expected test MSE, and refers ( )2  to the average test MSE that we would obtain if we repeatedly estimated f 
using a large number of training sets, and tested each at x 0 . The overall expected test MSE can be computed by averaging E − ˆ f(x 
0 ) over all y0  ( )2  possible values of x 0 in the test set.

ˆ f(x0 

Here the notation E

Equation 2.7 tells us that in order to minimize the expected test error, we need to select a statistical learning method that 
simultaneously achieves low variance and low bias. Note that variance is inherently a nonnegative quantity, and squared bias is also 
nonnegative. Hence, we see that the expected test MSE can never lie below Var(), the irreducible error from (2.3).

What do we mean by the variance and bias of a statistical learning method? Variance refers to the amount by which f ˆ would change if 
we estimated it using a diﬀerent training data set. Since the training data are used to ﬁt the statistical learning method, 
diﬀerent training data sets will result in a diﬀerent f. ˆ But ideally the estimate for f should not vary too much between training 
sets. However, if a method has high variance then small changes in the training data can result in large changes in f. ˆ In general, 
more ﬂexible statistical methods have higher variance. Consider the

green and orange curves in Figure 2.9. The ﬂexible green curve is following the observations very closely. It has high variance 
because changing any one of these data points may cause the estimate f ˆ to change considerably. In contrast, the orange least squares 
line is relatively inﬂexible and has low variance, because moving any single observation will likely cause only a small shift in the 
position of the line.

On the other hand, bias refers to the error that is introduced by approximating a real-life problem, which may be extremely 
complicated, by a much simpler model. For example, linear regression assumes that there is a linear relationship between Y and X 1 , X 
2 , . . . , X p . It is unlikely that any real-life problem truly has such a simple linear relationship, and so performing linear 
regression will undoubtedly result in some bias in the estimate of f. In Figure 2.11, the true f is substantially non-linear, so no 
matter how many training observations we are given, it will not be possible to produce an accurate estimate using linear regression. 
In other words, linear regression results in high bias in this example. However, in Figure 2.10 the true f is very close to linear, 
and so given enough data, it should be possible for linear regression to produce an accurate estimate. Generally, more ﬂexible 
methods result in less bias.

As a general rule, as we use more ﬂexible methods, the variance will increase and the bias will decrease. The relative rate of change 
of these two quantities determines whether the test MSE increases or decreases. As we increase the ﬂexibility of a class of methods, 
the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at 
some point increasing ﬂexibility has little impact on the bias but starts to signiﬁcantly increase the variance. When this happens 
the test MSE increases. Note that we observed this pattern of decreasing test MSE followed by increasing test MSE in the right-hand 
panels of Figures 2.9–2.11.

The three plots in Figure 2.12 illustrate Equation 2.7 for the examples in Figures 2.9–2.11. In each case the blue solid curve 
represents the squared bias, for diﬀerent levels of ﬂexibility, while the orange curve corresponds to the variance. The horizontal 
dashed line represents Var(), the irreducible error. Finally, the red curve, corresponding to the test set MSE, is the sum of these 
three quantities. In all three cases, the variance increases and the bias decreases as the method’s ﬂexibility increases. However, 
the ﬂexibility level corresponding to the optimal test MSE diﬀers considerably among the three data sets, because the squared bias 
and variance change at diﬀerent rates in each of the data sets. In the left-hand panel of Figure 2.12, the bias initially decreases 
rapidly, resulting in an initial sharp decrease in the expected test MSE. On the other hand, in the center panel of Figure 2.12 the 
true f is close to linear, so there is only a small decrease in bias as ﬂexibility increases, and the test MSE only declines slightly 
before increasing rapidly as the variance increases. Finally, in the right-hand panel of Figure 2.12, as ﬂexibility increases, there 
is a dramatic decline in bias because

FIGURE 2.12. Squared bias (blue curve), variance (orange curve), Var() (dashed line), and test MSE (red curve) for the three data sets 
in Figures 2.9–2.11. The vertical dotted line indicates the ﬂexibility level corresponding to the smallest test MSE.

2

5

10 Flexibility

20

0.0

0.5

1.0

1.5

2.0

2.5

MSE Bias Var

2

5

10 Flexibility

20

0

5

10

15

20

the true f is very non-linear. There is also very little increase in variance as ﬂexibility increases. Consequently, the test MSE 
declines substantially before experiencing a small increase as model ﬂexibility increases.

The relationship between bias, variance, and test set MSE given in Equation 2.7 and displayed in Figure 2.12 is referred to as the 
bias-variance trade-o ﬀ . Good test set performance of a statistical learning method requires low variance as well as low squared 
bias. This is referred to as a trade-oﬀ because it is easy to obtain a method with extremely low bias but high variance (for 
instance, by drawing a curve that passes through every single training observation) or a method with very low variance but high bias 
(by ﬁtting a horizontal line to the data). The challenge lies in ﬁnding a method for which both the variance and the squared bias 
are low. This trade-oﬀ is one of the most important recurring themes in this book.

In a real-life situation in which f is unobserved, it is generally not possible to explicitly compute the test MSE, bias, or variance 
for a statistical learning method. Nevertheless, one should always keep the bias-variance trade-oﬀ in mind. In this book we explore 
methods that are extremely ﬂexible and hence can essentially eliminate bias. However, this does not guarantee that they will 
outperform a much simpler method such as linear regression. To take an extreme example, suppose that the true f is linear. In this 
situation linear regression will have no bias, making it very hard for a more ﬂexible method to compete. In contrast, if the true f 
is highly non-linear and we have an ample number of training observations, then we may do better using a highly ﬂexible approach, as 
in Figure 2.11. In Chapter 5 we discuss cross-validation, which is a way to estimate the test MSE using the training data.

2.2.3 The Classiﬁcation Setting

Thus far, our discussion of model accuracy has been focused on the regression setting. But many of the concepts that we have 
encountered, such as the bias-variance trade-oﬀ, transfer over to the classiﬁcation setting with only some modiﬁcations due to the 
fact that y i is no longer numerical. Suppose that we seek to estimate f on the basis of training observations { (x 1 , y 1 ), . . . , 
(x n , y n ) } , where now y 1 , . . . , y n are qualitative. The most common approach for quantifying the accuracy of our estimate f 
ˆ is the training error rate, the proportion of mistakes that are made if we apply our estimate f ˆ to the training observations:

n 1 I(y i = yi ˆ ). n ∑ ̸ i=1

(2.8)

f. ˆ And

Here yi ˆ is the predicted class label for the ith observation using I(y i = yi ˆ ) is an indicator variable that equals 1 if y i = yi 
ˆ and zero if y i = yi ˆ . ̸ ̸ If I(y i = yi ˆ ) = 0 then the ith observation was classiﬁed correctly by our ̸ classiﬁcation method; 
otherwise it was misclassiﬁed. Hence Equation 2.8 computes the fraction of incorrect classiﬁcations.

Equation 2.8 is referred to as the training error rate because it is computed based on the data that was used to train our classiﬁer. 
As in the regression setting, we are most interested in the error rates that result from applying our classiﬁer to test observations 
that were not used in training. The test error rate associated with a set of test observations of the form (x 0 , y 0 ) is given by 
(2.9)

Ave (I(y 0 = y0 ˆ )) , ̸

where y0 ˆ is the predicted class label that results from applying the classiﬁer to the test observation with predictor x 0 . A good 
classiﬁer is one for which the test error (2.9) is smallest.

The Bayes Classiﬁer

It is possible to show (though the proof is outside of the scope of this book) that the test error rate given in (2.9) is minimized, 
on average, by a very simple classiﬁer that assigns each observation to the most likely class, given its predictor values. In other 
words, we should simply assign a test observation with predictor vector x 0 to the class j for which

Pr(Y = j | X = x 0 )

(2.10)

is largest. Note that (2.10) is a conditional probability: it is the probability that Y = j, given the observed predictor vector x 0 . 
This very simple classiﬁer is called the Bayes classiﬁer. In a two-class problem where there are only two possible response values, 
say class 1 or class 2, the Bayes classiﬁer

FIGURE 2.13. A simulated data set consisting of 100 observations in each of two groups, indicated in blue and in orange. The purple 
dashed line represents the Bayes decision boundary. The orange background grid indicates the region in which a test observation will 
be assigned to the orange class, and the blue background grid indicates the region in which a test observation will be assigned to the 
blue class.

corresponds to predicting class one if Pr(Y = 1 | X = x 0 ) > 0.5, and class two otherwise.

Figure 2.13 provides an example using a simulated data set in a two-dimensional space consisting of predictors X 1 and X 2 . The 
orange and blue circles correspond to training observations that belong to two diﬀerent classes. For each value of X 1 and X 2 , 
there is a diﬀerent probability of the response being orange or blue. Since this is simulated data, we know how the data were 
generated and we can calculate the conditional probabilities for each value of X 1 and X 2 . The orange shaded region reﬂects the set 
of points for which Pr(Y = orange | X) is greater than 50 %, while the blue shaded region indicates the set of points for which the 
probability is below 50 %. The purple dashed line represents the points where the probability is exactly 50 %. This is called the 
Bayes decision boundary. The Bayes classiﬁer’s prediction is determined by the Bayes decision boundary; an observation that falls on 
the orange side of the boundary will be assigned to the orange class, and similarly an observation on the blue side of the boundary 
will be assigned to the blue class.

The Bayes classiﬁer produces the lowest possible test error rate, called the Bayes error rate. Since the Bayes classiﬁer will always 
choose the class for which (2.10) is largest, the error rate at X = x 0 will be 1−max j Pr(Y = j | X = x 0 ). In general, the overall 
Bayes error rate is given by

1 − E max Pr(Y = j | X) , ( j )

(2.11)

Bayes decision boundary

Bayes error rate

where the expectation averages the probability over all possible values of X. For our simulated data, the Bayes error rate is 0.1304. 
It is greater than zero, because the classes overlap in the true population so max j Pr(Y = j | X = x 0 ) < 1 for some values of x 0 . 
The Bayes error rate is analogous to the irreducible error, discussed earlier.

K-Nearest Neighbors

In theory we would always like to predict qualitative responses using the Bayes classiﬁer. But for real data, we do not know the 
conditional distribution of Y given X, and so computing the Bayes classiﬁer is impossible. Therefore, the Bayes classiﬁer serves as 
an unattainable gold standard against which to compare other methods. Many approaches attempt to estimate the conditional distribution 
of Y given X, and then classify a given observation to the class with highest estimated probability. One such method is the K-nearest 
neighbors (KNN) classiﬁer. Given a positive integer K and a test observation x 0 , the KNN classiﬁer ﬁrst identiﬁes the K points 
in the training data that are closest to x 0 , represented by N 0 . It then estimates the conditional probability for class j as the 
fraction of points in N 0 whose response values equal j:

1 Pr(Y = j | X = x 0 ) = ∑ I(y i = j). K i ∈N0 

(2.12)

Finally, KNN applies Bayes rule and classiﬁes the test observation x 0 to the class with the largest probability.

Figure 2.14 provides an illustrative example of the KNN approach. In the left-hand panel, we have plotted a small training data set 
consisting of six blue and six orange observations. Our goal is to make a prediction for the point labeled by the black cross. Suppose 
that we choose K = 3. Then KNN will ﬁrst identify the three observations that are closest to the cross. This neighborhood is shown as 
a circle. It consists of two blue points and one orange point, resulting in estimated probabilities of 2/3 for the blue class and 1/3 
for the orange class. Hence KNN will predict that the black cross belongs to the blue class. In the right-hand panel of Figure 2.14 we 
have applied the KNN approach with K = 3 at all of the possible values for X 1 and X 2 , and have drawn in the corresponding KNN 
decision boundary.

Despite the fact that it is a very simple approach, KNN can often produce classiﬁers that are surprisingly close to the optimal Bayes 
classiﬁer. Figure 2.15 displays the KNN decision boundary, using K = 10, when applied to the larger simulated data set from Figure 
2.13. Notice that even though the true distribution is not known by the KNN classiﬁer, the KNN decision boundary is very close to 
that of the Bayes classiﬁer. The test error rate using KNN is 0.1363, which is close to the Bayes error rate of 0.1304.

FIGURE 2.14. The KNN approach, using K = 3, is illustrated in a simple situation with six blue observations and six orange 
observations. Left: a test observation at which a predicted class label is desired is shown as a black cross. The three closest points 
to the test observation are identiﬁed, and it is predicted that the test observation belongs to the most commonly-occurring class, in 
this case blue. Right: The KNN decision boundary for this example is shown in black. The blue grid indicates the region in which a 
test observation will be assigned to the blue class, and the orange grid indicates the region in which it will be assigned to the 
orange class.

o

o

o

o

o

o

o

o

o

o

o

o

The choice of K has a drastic eﬀect on the KNN classiﬁer obtained. Figure 2.16 displays two KNN ﬁts to the simulated data from 
Figure 2.13, using K = 1 and K = 100. When K = 1, the decision boundary is overly ﬂexible and ﬁnds patterns in the data that don’t 
correspond to the Bayes decision boundary. This corresponds to a classiﬁer that has low bias but very high variance. As K grows, the 
method becomes less ﬂexible and produces a decision boundary that is close to linear. This corresponds to a low-variance but 
high-bias classiﬁer. On this simulated data set, neither K = 1 nor K = 100 give good predictions: they have test error rates of 
0.1695 and 0.1925, respectively.

Just as in the regression setting, there is not a strong relationship between the training error rate and the test error rate. With K 
= 1, the KNN training error rate is 0, but the test error rate may be quite high. In general, as we use more ﬂexible classiﬁcation 
methods, the training error rate will decline but the test error rate may not. In Figure 2.17, we have plotted the KNN test and 
training errors as a function of 1/K. As 1/K increases, the method becomes more ﬂexible. As in the regression setting, the training 
error rate consistently declines as the ﬂexibility increases. However, the test error exhibits a characteristic U-shape, declining at 
ﬁrst (with a minimum at approximately K = 10) before increasing again when the method becomes excessively ﬂexible and overﬁts.

FIGURE 2.15. The black curve indicates the KNN decision boundary on the data from Figure 2.13, using K = 10. The Bayes decision 
boundary is shown as a purple dashed line. The KNN and Bayes decision boundaries are very similar.

FIGURE 2.16. A comparison of the KNN decision boundaries (solid black curves) obtained using K = 1 and K = 100 on the data from Figure 
2.13. With K = 1, the decision boundary is overly ﬂexible, while with K = 100 it is not su ﬃ ciently ﬂexible. The Bayes decision 
boundary is shown as a purple dashed line.

FIGURE 2.17. The KNN training error rate (blue, 200 observations) and test error rate (orange, 5,000 observations) on the data from 
Figure 2.13, as the level of ﬂexibility (assessed using 1/K) increases, or equivalently as the number of neighbors K decreases. The 
black dashed line indicates the Bayes error rate. The jumpiness of the curves is due to the small size of the training data set.

In both the regression and classiﬁcation settings, choosing the correct level of ﬂexibility is critical to the success of any 
statistical learning method. The bias-variance tradeoﬀ, and the resulting U-shape in the test error, can make this a diﬃcult task. 
In Chapter 5, we return to this topic and discuss various methods for estimating test error rates and thereby choosing the optimal 
level of ﬂexibility for a given statistical learning method.

2.3 Lab: Introduction to R

In this lab, we will introduce some simple R commands. The best way to learn a new language is to try out the commands. R can be 
downloaded from

http://cran.r-project.org/

2.3.1 Basic Commands

R uses functions to perform operations. To run a function called funcname, we type funcname(input1, input2), where the inputs (or 
arguments) input1

and input2 tell R how to run the function. A function can have any number of inputs. For example, to create a vector of numbers, we 
use the function c() (for concatenate). Any numbers inside the parentheses are joined together. The following command instructs R to 
join together the numbers 1, 3, 2, and 5, and to save them as a vector named x. When we type x, it gives us back the vector.

> x <- c(1,3,2,5)

> x

[1] 1 3 2 5

Note that the > is not part of the command; rather, it is printed by R to indicate that it is ready for another command to be entered. 
We can also save things using = rather than <-:

> x = c(1,6,2)

> x

[1] 1 6 2

> y = c(1,4,3)

Hitting the up arrow multiple times will display the previous commands, which can then be edited. This is useful since one often 
wishes to repeat a similar command. In addition, typing ?funcname will always cause R to open a new help ﬁle window with additional 
information about the function funcname.

We can tell R to add two sets of numbers together. It will then add the ﬁrst number from x to the ﬁrst number from y, and so on. 
However, x and y should be the same length. We can check their length using the length() function.

> length (x)

[1] 3

> length (y)

[1] 3

> x+y

[1] 2 10

5

The ls() function allows us to look at a list of all of the objects, such as data and functions, that we have saved so far. The rm() 
function can be used to delete any that we don’t want.

> ls()

[1] " x" " y"

> rm(x,y)

> ls()

character (0)

It’s also possible to remove all objects at once:

c()

vector

length()

ls() rm()

> rm(list=ls())

The matrix() function can be used to create a matrix of numbers. Before we use the matrix() function, we can learn more about it:

> ? matrix

The help ﬁle reveals that the matrix() function takes a number of inputs, but for now we focus on the ﬁrst three: the data (the 
entries in the matrix), the number of rows, and the number of columns. First, we create a simple matrix.

> x=matrix (data=c(1,2,3,4) , nrow=2, ncol =2)

> x

matrix()

[,1] [,2]

[1,]

1

3

[2,]

2

4

Note that we could just as well omit typing data=, nrow=, and ncol= in the matrix() command above: that is, we could just type

> x=matrix (c(1,2,3,4) ,2,2)

and this would have the same eﬀect. However, it can sometimes be useful to specify the names of the arguments passed in, since 
otherwise R will assume that the function arguments are passed into the function in the same order that is given in the function’s 
help ﬁle. As this example illustrates, by default R creates matrices by successively ﬁlling in columns. Alternatively, the 
byrow=TRUE option can be used to populate the matrix in order of the rows.

> matrix (c(1,2,3,4) ,2,2,byrow =TRUE)

[,1] [,2]

[1,]

1

2

[2,]

3

4

Notice that in the above command we did not assign the matrix to a value such as x. In this case the matrix is printed to the screen 
but is not saved for future calculations. The sqrt() function returns the square root of each element of a vector or matrix. The 
command x^2 raises each element of x to the power 2; any powers are possible, including fractional or negative powers.

> sqrt(x)

sqrt()

[,1] [,2]

[1,] 1.00

1.73

[2,] 1.41

2.00

> x^2

[,1] [,2]

[1,]

1

9

[2,]

4

16

The rnorm() function generates a vector of random normal variables, with ﬁrst argument n the sample size. Each time we call this 
function, we will get a diﬀerent answer. Here we create two correlated sets of numbers, x and y, and use the cor() function to 
compute the correlation between them.

> x=rnorm (50)

> y=x+rnorm (50, mean=50, sd=.1)

> cor(x,y)

[1] 0.995

By default, rnorm() creates standard normal random variables with a mean of 0 and a standard deviation of 1. However, the mean and 
standard deviation can be altered using the mean and sd arguments, as illustrated above. Sometimes we want our code to reproduce the 
exact same set of random numbers; we can use the set.seed() function to do this. The set.seed() function takes an (arbitrary) integer 
argument.

> set.seed (1303)

> rnorm (50)

[1] -1.1440

1.3421 2.1854

0.5364 0.0632

0.5022 -0.0004

. . .

We use set.seed() throughout the labs whenever we perform calculations involving random quantities. In general this should allow the 
user to reproduce our results. However, it should be noted that as new versions of R become available it is possible that some small 
discrepancies may form between the book and the output from R.

The mean() and var() functions can be used to compute the mean and variance of a vector of numbers. Applying sqrt() to the output of 
var() will give the standard deviation. Or we can simply use the sd() function.

> set.seed (3)

> y=rnorm (100)

> mean(y)

[1] 0.0110

> var(y)

[1] 0.7329

> sqrt(var(y))

[1] 0.8561

> sd(y)

[1] 0.8561

2.3.2 Graphics

The plot() function is the primary way to plot data in R. For instance, plot(x,y) produces a scatterplot of the numbers in x versus 
the numbers in y. There are many additional options that can be passed in to the plot() function. For example, passing in the argument 
xlab will result in a label on the x-axis. To ﬁnd out more information about the plot() function, type ?plot.

> x=rnorm (100)

> y=rnorm (100)

> plot(x,y)

> plot(x,y,xlab=" this is

the

x-axis" ,ylab=" this

is

the y-axis" ,

set.seed()

mean() var()

sd()

plot()

main=" Plot of X vs Y" )

We will often want to save the output of an R plot. The command that we use to do this will depend on the ﬁle type that we would like 
to create. For instance, to create a pdf, we use the pdf() function, and to create a jpeg, we use the jpeg() function.

> pdf (" Figure .pdf " )

> plot(x,y,col =" green " )

> dev.off ()

null device

pdf()

jpeg()

1

The function dev.off() indicates to R that we are done creating the plot. Alternatively, we can simply copy the plot window and paste 
it into an appropriate ﬁle type, such as a Word document.

The function seq() can be used to create a sequence of numbers. For instance, seq(a,b) makes a vector of integers between a and b. 
There are many other options: for instance, seq(0,1,length=10) makes a sequence of 10 numbers that are equally spaced between 0 and 1. 
Typing 3:11 is a shorthand for seq(3,11) for integer arguments.

> x=seq (1 ,10)

> x

[1] 1

2

3

4

5

6

7

8

9 10

> x=1:10

> x

[1] 1

2

3

4

5

6

7

8

9 10

> x=seq(-pi ,pi ,length =50)

We will now create some more sophisticated plots. The contour() function produces a contour plot in order to represent 
three-dimensional data; it is like a topographical map. It takes three arguments:

1. A vector of the x values (the ﬁrst dimension),

2. A vector of the y values (the second dimension), and

3. A matrix whose elements correspond to the z value (the third dimension) for each pair of (x,y) coordinates.

As with the plot() function, there are many other inputs that can be used to ﬁne-tune the output of the contour() function. To learn 
more about these, take a look at the help ﬁle by typing ?contour.

> y=x

> f=outer(x,y,function (x,y)cos(y)/(1+x^2))

> contour (x,y,f)

> contour (x,y,f,nlevels =45, add=T)

> fa=(f-t(f))/2

> contour (x,y,fa,nlevels =15)

The image() function works the same way as contour(), except that it produces a color-coded plot whose colors depend on the z value. 
This is

known as a heatmap, and is sometimes used to plot temperature in weather forecasts. Alternatively, persp() can be used to produce a 
three-dimensional plot. The arguments theta and phi control the angles at which the plot is viewed.

heatmap

persp()

> image(x,y,fa)

> persp(x,y,fa)

> persp(x,y,fa ,theta =30)

> persp(x,y,fa ,theta =30, phi =20)

> persp(x,y,fa ,theta =30, phi =70)

> persp(x,y,fa ,theta =30, phi =40)

2.3.3 Indexing Data

We often wish to examine part of a set of data. Suppose that our data is stored in the matrix A.

> A=matrix (1:16 ,4 ,4)

> A

[,1] [,2]

[,3] [,4]

[1,]

1

5

9

13

[2,]

2

6

10

14

[3,]

3

7

11

15

[4,]

4

8

12

16

Then, typing

> A[2,3]

[1] 10

will select the element corresponding to the second row and the third column. The ﬁrst number after the open-bracket symbol [ always 
refers to the row, and the second number always refers to the column. We can also select multiple rows and columns at a time, by 
providing vectors as the indices.

> A[c(1,3) ,c(2,4) ]

[,1] [,2]

[1,]

5

13

[2,]

7

15

> A[1:3 ,2:4]

[,1] [,2]

[,3]

[1,]

5

9

13

[2,]

6

10

14

[3,]

7

11

15

> A[1:2 ,]

[,1] [,2]

[,3] [,4]

[1,]

1

5

9

13

[2,]

2

6

10

14

> A[ ,1:2]

[,1] [,2]

[1,]

1

5

[2,]

2

6

[3,]

3

7

[4,]

4

8

The last two examples include either no index for the columns or no index for the rows. These indicate that R should include all 
columns or all rows, respectively. R treats a single row or column of a matrix as a vector.

> A[1,]

[1] 1

5

9 13

The use of a negative sign - in the index tells R to keep all rows or columns except those indicated in the index.

> A[-c(1,3) ,]

[,1] [,2]

[,3] [,4]

[1,]

2

6

10

14

[2,]

4

8

12

16

> A[-c(1,3) ,-c(1,3,4)]

[1] 6 8

The dim() function outputs the number of rows followed by the number of columns of a given matrix.

> dim(A)

[1] 4 4

2.3.4 Loading Data

For most analyses, the ﬁrst step involves importing a data set into R. The read.table() function is one of the primary ways to do 
this. The help ﬁle contains details about how to use this function. We can use the function write.table() to export data.

Before attempting to load a data set, we must make sure that R knows to search for the data in the proper directory. For example on a 
Windows system one could select the directory using the Change dir. . . option under the File menu. However, the details of how to do 
this depend on the operating system (e.g. Windows, Mac, Unix) that is being used, and so we do not give further details here. We begin 
by loading in the Auto data set. This data is part of the ISLR library (we discuss libraries in Chapter 3) but to illustrate the 
read.table() function we load it now from a text ﬁle. The following command will load the Auto.data ﬁle into R and store it as an 
object called Auto, in a format referred to as a data frame. (The text ﬁle can be obtained from this book’s website.) Once the data 
has been loaded, the fix() function can be used to view it in a spreadsheet like window. However, the window must be closed before 
further R commands can be entered.

> Auto=read.table (" Auto.data " )

> fix(Auto)

Note that Auto.data is simply a text ﬁle, which you could alternatively open on your computer using a standard text editor. It is 
often a good idea to view a data set using a text editor or other software such as Excel before loading it into R.

This particular data set has not been loaded correctly, because R has assumed that the variable names are part of the data and so has 
included them in the ﬁrst row. The data set also includes a number of missing observations, indicated by a question mark ?. Missing 
values are a common occurrence in real data sets. Using the option header=T (or header=TRUE) in the read.table() function tells R that 
the ﬁrst line of the ﬁle contains the variable names, and using the option na.strings tells R that any time it sees a particular 
character or set of characters (such as a question mark), it should be treated as a missing element of the data matrix.

> Auto=read.table (" Auto.data" , header =T,na.strings =" ? " )

> fix(Auto)

Excel is a common-format data storage program. An easy way to load such data into R is to save it as a csv (comma separated value) 
ﬁle and then use the read.csv() function to load it in.

> Auto=read.csv (" Auto.csv" , header =T,na.strings =" ? " )

> fix(Auto)

> dim(Auto)

[1] 397 9

> Auto [1:4 ,]

The dim() function tells us that the data has 397 observations, or rows, and nine variables, or columns. There are various ways to 
deal with the missing data. In this case, only ﬁve of the rows contain missing observations, and so we choose to use the na.omit() 
function to simply remove these rows.

> Auto=na.omit(Auto)

> dim(Auto)

[1] 392

9

Once the data are loaded correctly, we can use names() to check the variable names.

2.3.5 Additional Graphical and Numerical Summaries

We can use the plot() function to produce scatterplots of the quantitative variables. However, simply typing the variable names will 
produce an error message, because R does not know to look in the Auto data set for those variables.

> plot(cylinders , mpg)

Error in

plot(cylinders , mpg) : object

’cylinders ’ not found

To refer to a variable, we must type the data set and the variable name joined with a $ symbol. Alternatively, we can use the attach() 
function in order to tell R to make the variables in this data frame available by name.

> plot(Auto$cylinders ,

Auto$mpg )

> attach (Auto)

> plot(cylinders , mpg)

The cylinders variable is stored as a numeric vector, so R has treated it as quantitative. However, since there are only a small 
number of possible values for cylinders, one may prefer to treat it as a qualitative variable. The as.factor() function converts 
quantitative variables into qualitative variables.

> cylinders =as.factor (cylinders )

If the variable plotted on the x-axis is categorial, then boxplots will automatically be produced by the plot() function. As usual, a 
number of options can be speciﬁed in order to customize the plots.

> plot(cylinders , mpg)

> plot(cylinders , mpg ,

col =" red " )

> plot(cylinders , mpg ,

col =" red" ,

varwidth =T)

> plot(cylinders , mpg ,

col =" red" ,

varwidth =T,horizontal =T)

> plot(cylinders , mpg ,

col =" red" ,

varwidth =T,

xlab=" cylinders " ,

attach()

as.factor()

boxplot

ylab =" MPG " )

The hist() function can be used to plot a histogram. Note that col=2 has the same eﬀect as col="red".

> hist(mpg)

> hist(mpg ,col =2)

> hist(mpg ,col =2, breaks =15)

The pairs() function creates a scatterplot matrix i.e. a scatterplot for every pair of variables for any given data set. We can also 
produce scatterplots for just a subset of the variables.

> pairs(Auto)

> pairs(∼ mpg

+ displacement + horsepower

+ weight

+

hist()

histogram

scatterplot matrix

acceleration , Auto)

In conjunction with the plot() function, identify() provides a useful interactive method for identifying the value for a particular 
variable for points on a plot. We pass in three arguments to identify(): the x-axis variable, the y-axis variable, and the variable 
whose values we would like to see printed for each point. Then clicking on a given point in the plot will cause R to print the value 
of the variable of interest. Right-clicking on the plot will exit the identify() function (control-click on a Mac). The numbers 
printed under the identify() function correspond to the rows for the selected points.

> plot(horsepower ,mpg)

> identify (horsepower ,mpg ,name)

The summary() function produces a numerical summary of each variable in a particular data set.

> summary (Auto)

summary()

mpg

cylinders

displacement

Min.

:

9.00

Min .

:3.000

Min.

: 68.0

1st Qu .:17.00

1st Qu .:4.000

1st

Qu .:105.0

Median

:22.75

Median

:4.000

Median

:151.0

Mean

:23.45

Mean

:5.472

Mean

:194.4

3rd Qu .:29.00

3rd Qu .:8.000

3rd

Qu .:275.8

Max.

:46.60

Max .

:8.000

Max.

:455.0

horsepower

weight

acceleration

Min.

:

46.0

Min .

:1613

Min .

: 8.00

1st Qu.:

75.0

1st Qu .:2225

1st

Qu .:13.78

Median :

93.5

Median

:2804

Median

:15.50

Mean

:104.5

Mean

:2978

Mean

:15.54

3rd Qu .:126.0

3rd Qu .:3615

3rd

Qu .:17.02

Max.

:230.0

Max .

:5140

Max .

:24.80

year

origin

name

Min.

:70.00

Min .

:1.000

amc

matador

:

5

1st Qu .:73.00

1st Qu .:1.000

ford

pinto

:

5

Median

:76.00

Median

:1.000

toyota

corolla

:

5

Mean

:75.98

Mean

:1.577

amc

gremlin

:

4

3rd Qu .:79.00

3rd Qu .:2.000

amc

hornet

:

4

Max.

:82.00

Max .

:3.000

chevrolet

chevette :

4

(Other)

:365

For qualitative variables such as name, R will list the number of observations that fall in each category. We can also produce a 
summary of just a single variable.

> summary (mpg)

Min. 1st

Qu.

Median

Mean 3rd

Qu.

Max .

9.00

17.00

22.75

23.45

29.00

46.60

Once we have ﬁnished using R, we type q() in order to shut it down, or quit. When exiting R, we have the option to save the current 
workspace so that all objects (such as data sets) that we have created in this R session will be available next time. Before exiting 
R, we may want to save a record of all of the commands that we typed in the most recent session; this can be accomplished using the 
savehistory() function. Next time we enter R, we can load that history using the loadhistory() function.

2.4 Exercises

Conceptual

1. For each of parts (a) through (d), indicate whether we would generally expect the performance of a ﬂexible statistical learning 
method to be better or worse than an inﬂexible method. Justify your answer.

(a) The sample size n is extremely large, and the number of predictors p is small.

(b) The number of predictors p is extremely large, and the number of observations n is small.

(c) The relationship between the predictors and response is highly non-linear.

(d) The variance of the error terms, i.e. σ 2 = Var(), is extremely high.

2. Explain whether each scenario is a classiﬁcation or regression problem, and indicate whether we are most interested in inference 
or prediction. Finally, provide n and p.

(a) We collect a set of data on the top 500 ﬁrms in the US. For each ﬁrm we record proﬁt, number of employees, industry and the CEO 
salary. We are interested in understanding which factors aﬀect CEO salary.

(b) We are considering launching a new product and wish to know whether it will be a success or a failure. We collect data on 20 
similar products that were previously launched. For each product we have recorded whether it was a success or failure, price charged 
for the product, marketing budget, competition price, and ten other variables.

(c) We are interesting in predicting the % change in the US dollar in relation to the weekly changes in the world stock markets. Hence 
we collect weekly data for all of 2012. For each week we record the % change in the dollar, the % change in the US market, the % 
change in the British market, and the % change in the German market.

3. We now revisit the bias-variance decomposition.

(a) Provide a sketch of typical (squared) bias, variance, training error, test error, and Bayes (or irreducible) error curves, on a 
single plot, as we go from less ﬂexible statistical learning methods towards more ﬂexible approaches. The x-axis should represent

the amount of ﬂexibility in the method, and the y-axis should represent the values for each curve. There should be ﬁve curves. Make 
sure to label each one.

(b) Explain why each of the ﬁve curves has the shape displayed in part (a).

4. You will now think of some real-life applications for statistical learning.

(a) Describe three real-life applications in which classiﬁcation might be useful. Describe the response, as well as the predictors. 
Is the goal of each application inference or prediction? Explain your answer.

(b) Describe three real-life applications in which regression might be useful. Describe the response, as well as the predictors. Is 
the goal of each application inference or prediction? Explain your answer.

(c) Describe three real-life applications in which cluster analysis might be useful.

5. What are the advantages and disadvantages of a very ﬂexible (versus a less ﬂexible) approach for regression or classiﬁcation? 
Under what circumstances might a more ﬂexible approach be preferred to a less ﬂexible approach? When might a less ﬂexible approach 
be preferred?

6. Describe the diﬀerences between a parametric and a non-parametric statistical learning approach. What are the advantages of a 
parametric approach to regression or classiﬁcation (as opposed to a nonparametric approach)? What are its disadvantages?

7. The table below provides a training data set containing six observations, three predictors, and one qualitative response variable.

Obs.

1

2

3

4

5

6

X1 

0 2 0 0 −1 1

X2 

3

0

1

1

0

1

X3 

0

0

3

2

1

1

Y

Red Red Red Green Green Red

Suppose we wish to use this data set to make a prediction for Y when X 1 = X 2 = X 3 = 0 using K-nearest neighbors.

the test point, X 1 = X 2 = X 3 = 0.

(a) Compute the Euclidean distance between ea

(b) What is our prediction with K = 1? Why?

(c) What is our prediction with K = 3? Why?

(d) If the Bayes decision boundary in this problem is highly nonlinear, then would we expect the best value for K to be large or 
small? Why?

Applied

8. This exercise relates to the College data set, which can be found in the ﬁle College.csv. It contains a number of variables for 
777 diﬀerent universities and colleges in the US. The variables are

• Private : Public/private indicator

• Apps : Number of applications received

• Accept : Number of applicants accepted

• Enroll : Number of new students enrolled

• Top10perc : New students from top 10 % of high school class

• Top25perc : New students from top 25 % of high school class

• F.Undergrad : Number of full-time undergraduates

• P.Undergrad : Number of part-time undergraduates

• Outstate : Out-of-state tuition

• Room.Board : Room and board costs

• Books : Estimated book costs

• Personal : Estimated personal spending

• PhD : Percent of faculty with Ph.D.’s

• Terminal : Percent of faculty with terminal degree

• S.F.Ratio : Student/faculty ratio

• perc.alumni : Percent of alumni who donate

• Expend : Instructional expenditure per student

• Grad.Rate : Graduation rate

Before reading the data into R, it can be viewed in Excel or a text editor.

(a) Use the read.csv() function to read the data into R. Call the loaded data college. Make sure that you have the directory set to 
the correct location for the data.

(b) Look at the data using the fix() function. You should notice that the ﬁrst column is just the name of each university. We don’t 
really want R to treat this as data. However, it may be handy to have these names for later. Try the following commands:

> rownames (college )=college [,1]

> fix (college )

You should see that there is now a row.names column with the name of each university recorded. This means that R has given each row a 
name corresponding to the appropriate university. R will not try to perform calculations on the row names. However, we still need to 
eliminate the ﬁrst column in the data where the names are stored. Try

> college =college [,-1]

> fix (college )

Now you should see that the ﬁrst data column is Private. Note that another column labeled row.names now appears before the Private 
column. However, this is not a data column but rather the name that R is giving to each row.

(c) i. Use the summary() function to produce a numerical summary of the variables in the data set.

ii. Use the pairs() function to produce a scatterplot matrix of the ﬁrst ten columns or variables of the data. Recall that you can 
reference the ﬁrst ten columns of a matrix A using A[,1:10].

iii. Use the plot() function to produce side-by-side boxplots of Outstate versus Private.

iv. Create a new qualitative variable, called Elite, by binning the Top10perc variable. We are going to divide universities into two 
groups based on whether or not the proportion of students coming from the top 10 % of their high school classes exceeds 50 %.

> Elite =rep (" No" ,nrow(college ))

> Elite [college$Top10perc >50]=" Yes"

> Elite =as.factor (Elite)

> college =data.frame(college ,Elite)

Use the summary() function to see how many elite universities there are. Now use the plot() function to produce side-by-side boxplots 
of Outstate versus Elite.

v. Use the hist() function to produce some histograms with diﬀering numbers of bins for a few of the quantitative variables. You may 
ﬁnd the command par(mfrow=c(2,2)) useful: it will divide the print window into four regions so that four plots can be made 
simultaneously. Modifying the arguments to this function will divide the screen in other ways.

vi. Continue exploring the data, and provide a brief summary of what you discover.

9. This exercise involves the Auto data set studied in the lab. Make sure that the missing values have been removed from the data.

(a) Which of the predictors are quantitative, and which are qualitative?

(b) What is the range of each quantitative predictor? You can answer this using the range() function.

range()

(c) What is the mean and standard deviation of each quantitative predictor?

(d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of 
the data that remains?

(e) Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some 
plots highlighting the relationships among the predictors. Comment on your ﬁndings.

(f) Suppose that we wish to predict gas mileage (mpg) on the basis of the other variables. Do your plots suggest that any of the other 
variables might be useful in predicting mpg? Justify your answer.

10. This exercise involves the Boston housing data set.

(a) To begin, load in the Boston data set. The Boston data set is part of the MASS library in R.

> library (MASS)

Now the data set is contained in the object Boston.

> Boston

Read about the data set:

> ? Boston

How many rows are in this data set? How many columns? What do the rows and columns represent?

(b) Make some pairwise scatterplots of the predictors (columns) in this data set. Describe your ﬁndings.

(c) Are any of the predictors associated with per capita crime rate?

If so, explain the relationship.

(d) Do any of the suburbs of Boston appear to have particularly high crime rates? Tax rates? Pupil-teacher ratios? Comment on the 
range of each predictor.

(e) How many of the suburbs in this data set bound the Charles river?

(f) What is the median pupil-teacher ratio among the towns in this data set?

(g) Which suburb of Boston has lowest median value of owner-occupied homes? What are the values of the other predictors for that 
suburb, and how do those values compare to the overall ranges for those predictors? Comment on your ﬁndings.

(h) In this data set, how many of the suburbs average more than seven rooms per dwelling? More than eight rooms per dwelling? Comment 
on the suburbs that average more than eight rooms per dwelling.


