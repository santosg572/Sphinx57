
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Lagrange Interpolation Approach for General Parameter-Shift Rule &#8212; Calculo 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Applied_Delay_Differential_Equations" href="../Applied_Delay_Differential_Equations/index2.html" />
    <link rel="prev" title="&lt;no title&gt;" href="index2.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="lagrange-interpolation-approach-for-general-parameter-shift-rule">
<h1>Lagrange Interpolation Approach for General Parameter-Shift Rule<a class="headerlink" href="#lagrange-interpolation-approach-for-general-parameter-shift-rule" title="Permalink to this headline">¶</a></h1>
<p>Vu Tuan Hai and Le Bin Ho</p>
<section id="introduction">
<h2>1 Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Quantum computing is an elegant fusion between computer science and principles
of quantum physics to facilitate calculations [1]. It promises an excellent computational capacity that is intractable for classical computers to solve challenging
problems, including materials science, information science, computer science,
mathematical science, and others. However, it turns out that fault-tolerant quantum
computers are challenging to realize due to: (i) the difficulty of accessing complete
information from entangled systems because of the state collapse upon measurements, and (ii) the difficulty of building, controlling, and measuring quantum states
with arbitrarily high accuracy [2]. In this regard, despite the tremendous rate of
development, the current state-of-the-art quantum computers mainly contain a small
number of quantum bits (qubits) with a noise level called the noisy intermediate-
scale quantum devices (NISQ) that prevents them from being practical [3].</p>
<p>La computación cuántica es una elegante fusión entre la ciencia de la computación y los principios de la física cuántica
para facilitar los cálculos [1]. Promete una excelente capacidad computacional que es intratable para las computadoras
clásicas para resolver problemas desafiantes, incluyendo la ciencia de los materiales, la ciencia de la información, la
ciencia de la computación, la ciencia matemática y otras. Sin embargo, resulta que las computadoras cuánticas tolerantes
a fallas son difíciles de implementar debido a: (i) la dificultad de acceder a información completa de sistemas
entrelazados debido al colapso del estado en las mediciones, y (ii) la dificultad de construir, controlar y medir estados
cuánticos con una precisión arbitrariamente alta [2]. En este sentido, a pesar del tremendo ritmo de desarrollo, las
computadoras cuánticas de última generación actuales contienen principalmente una pequeña cantidad de bits cuánticos
(qubits) con un nivel de ruido llamado dispositivos cuánticos de escala intermedia ruidosos (NISQ) que les impide ser
prácticos [3].</p>
<p>Variational quantum algorithms (VQAs) are promising to speed up the computing capacity in the NISQ computers [4]. Massive applications of the VQAs
were extensively reported, from dynamic simulation to condensed matter physics,
machine learning, mathematical applications, and new frontiers quantum foundations [4]. The main task of VQAs is to optimize a trainable parameterized circuit by
using a hybrid quantum-classical scheme, as shown in Fig. 1. Here, one measures
the cost function of interest C(θ) in the quantum part and iteratively optimize it in
the classical part until it converts. The optimization can use either gradient-free or
gradient-based methods.</p>
<p>Los algoritmos cuánticos variacionales (VQA) prometen acelerar la capacidad de cómputo de los ordenadores NISQ [4]. Se
han reportado extensas aplicaciones de los VQA, desde simulación dinámica hasta física de la materia condensada,
aprendizaje automático, aplicaciones matemáticas y fundamentos cuánticos de nuevas fronteras [4]. La tarea principal de
los VQA es optimizar un circuito parametrizado y entrenable mediante un esquema híbrido cuántico-clásico, como se muestra
en la Fig. 1. En este caso, se mide la función de coste de interés C(θ) en la parte cuántica y se optimiza iterativamente
en la parte clásica hasta que se convierte. La optimización puede utilizar métodos sin gradiente o basados ​​en gradiente.</p>
<p>A critical technique for the VQAs to compute analytic derivatives of the cost
function is known as the “parameter-shift rule” [5, 6], which is often required for
the gradient-based optimization. The method was first introduced by Mitarai et al.
[5] and then extended to a so-call two-term parameter-shift rule [6]. This approach
gives the exact gradient (first-order derivative) of the cost function by subtracting
the two cost functions with different shifts. It is, however, only applicable for single-
qubit quantum gates, whose generators have two distinguished eigenvalues, such as
the rotation gates [7, 8]. So far, Anselmetti et al. introduced a four-term parameter-
shift rule that applies to generators with three distinguished eigenvalues {−1, 0, 1},
such as the controlled-rotation gates [9]. In this case, the derivative is given in the
linear combination of four cost functions with different shifts. Recently, various
attempts were devoted to generalizing the parameter-shift rule for any assigned
quantum gates [10–12]. Remarkably, strategies for generalizing using polynomial
expansion were proposed [11, 12]. Apart from that, Wierichs et al. introduced a
general parameter-shift rule based on the finite Fourier series of the cost function
[10]. However, this method heavily consumes cost of computation to evaluate all
Fourier coefficients. So far, higher-order parameter-shift rule is also derived [13],
such as the second-order derivative can reduce to the Hessian formula of the finite
differential.</p>
<p>Una técnica crítica para que los VQA calculen las derivadas analíticas de la función de coste se conoce como la “regla de
desplazamiento de parámetros” [5, 6], que a menudo se requiere para la optimización basada en gradientes. El método fue
introducido por primera vez por Mitarai et al. [5] y luego se extendió a la llamada regla de desplazamiento de parámetros
de dos términos [6]. Este enfoque proporciona el gradiente exacto (derivada de primer orden) de la función de coste
restando las dos funciones de coste con diferentes desplazamientos. Sin embargo, solo es aplicable para puertas cuánticas
de un solo cúbit, cuyos generadores tienen dos valores propios distinguidos, como las puertas de rotación [7, 8]. Hasta
ahora, Anselmetti et al. introdujeron una regla de desplazamiento de parámetros de cuatro términos que se aplica a
generadores con tres valores propios distinguidos {−1, 0, 1}, como las puertas de rotación controlada [9]. En este caso,
la derivada se da en la combinación lineal de cuatro funciones de coste con diferentes desplazamientos. Recientemente, se
han realizado varios intentos para generalizar la regla de desplazamiento de parámetros para cualquier puerta cuántica
asignada [10–12]. Cabe destacar que se propusieron estrategias de generalización mediante expansión polinómica [11, 12].
Además, Wierichs et al. introdujeron una regla general de desplazamiento de parámetros basada en la serie finita de
Fourier de la función de coste [10]. Sin embargo, este método requiere un alto coste computacional para evaluar todos los
coeficientes de Fourier. Hasta la fecha, también se ha derivado una regla de desplazamiento de parámetros de orden
superior [13], como la reducción de la derivada de segundo orden a la fórmula hessiana de la diferencial finita.</p>
<p>In this work, we introduce the Lagrange
interpolation approach [14, 15] to derive the general parameter-shift rule. We expand a quantum gate having a generator
G into a polynomial P (G) of degree n − 1, where n is the number of distinct
eigenvalues of G. Our approach is similar to the polynomial expansion Refs.
[11, 12]. However, here, we provide a general procedure to derive the parameter-
shift rule for arbitrary distinct eigenvalues automatically. It only requires fewer
evaluations to compute the derivative. We illustrate the approach for the well-known
two-term and four-term parameter-shift rules, and generalize to multiple-term
parameter-shift rule. Higher-order derivatives of the cost function are also discussed.
We finally numerically evaluate the accuracy of the method via the mean-square
error and demonstrate the variational quantum eigensolver for a many-body system.
So far, our approach can be applied to trapped atomic ions quantum gates, such as
collective quantum gates, whose generators have linear eigenvalues as number of
particles [16, 17].</p>
<p>En este trabajo, introducimos el enfoque de interpolación de Lagrange [14, 15] para derivar la regla general de
desplazamiento de parámetros. Expandimos una compuerta cuántica que tiene un generador G en un polinomio P (G) de grado n
− 1, donde n es el número de autovalores distintos de G. Nuestro enfoque es similar a la expansión polinómica Refs. [11,
12]. Sin embargo, aquí, proporcionamos un procedimiento general para derivar automáticamente la regla de desplazamiento
de parámetros para autovalores distintos arbitrarios. Solo requiere menos evaluaciones para calcular la derivada.
Ilustramos el enfoque para las bien conocidas reglas de desplazamiento de parámetros de dos y cuatro términos, y lo
generalizamos a la regla de desplazamiento de parámetros de múltiples términos. También se discuten las derivadas de
orden superior de la función de costo. Finalmente, evaluamos numéricamente la precisión del método a través del error
cuadrático medio y demostramos el solucionador de autovalores cuánticos variacional para un sistema de muchos cuerpos.
Hasta ahora, nuestro enfoque se puede aplicar a puertas cuánticas de iones atómicos atrapados, como las puertas cuánticas
colectivas, cuyos generadores tienen valores propios lineales como número de partículas [16, 17].</p>
<p>For convenience, in Table 1, we present the major symbols used in this work.</p>
</section>
<section id="preliminary">
<h2>2 Preliminary<a class="headerlink" href="#preliminary" title="Permalink to this headline">¶</a></h2>
<p>Let us consider a parameterized quantum gate with a general form U(x) = e−i x
2 G where G is the generator and assume the cost function of interest is the expectation
value of a measured observable B as</p>
<p>Consideremos una puerta cuántica parametrizada con una forma general <span class="math notranslate nohighlight">\(U(x) = e^{−i \frac{x}{2} G}\)</span> donde G es el
generador y
supongamos que la función de costo de interés es el valor esperado de un observable medido B como</p>
<div class="math notranslate nohighlight">
\[C(x) = &lt;ψ|U^†(x)BU(x)|ψ&gt;,\]</div>
<ol class="arabic simple">
<li></li>
</ol>
<p>where <a href="#id1"><span class="problematic" id="id2">|</span></a>ψ&gt; is the initial circuit’s state. The derivative w.r.t the parameter x yields</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{∂} C(x) = −\frac{i}{2}&lt;ψ|U^†(x)[B, G]U(x)|ψ&gt;.\]</div>
<ol class="arabic simple" start="2">
<li></li>
</ol>
<p>For generators that obey <span class="math notranslate nohighlight">\(G^2 = I\)</span> , such as the standard rotation gates based on Pauli
matrices <span class="math notranslate nohighlight">\(G = \{σ_x , σ_y , σ_z\}\)</span> or <span class="math notranslate nohighlight">\(G^2 = G\)</span>, such as projective operators, we have</p>
<div class="math notranslate nohighlight">
\[[B, G] = \frac{i}{\sin(α)}[U^†(α)BU(α) -U^†(−α)BU(−α)]\]</div>
<p>, (3)</p>
<p>where α is an arbitrary shift. Substituting (3) to (2) results in a two-term parameter-
shift rule as [6]</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{∂}{∂} C(x) = \frac{1{\\2 sin(α)}[C(x + α) − C(x − α)]\end{split}\]</div>
<p>, (4)</p>
<p>where the gradient is proportional to the linear combination in the cost functions
with different shifts +α and −α. It is summarized in a scheme below:</p>
<p>This is the well-known parameter-shift rule used in various VQA approaches [4]. In
the following, we derive the parameter-shift rule for general quantum gates by using
the Lagrange interpolation.</p>
</section>
<section id="general-parameter-shift-rule-with-the-lagrange-interpolation-approach">
<h2>3 General Parameter-Shift Rule with the Lagrange Interpolation Approach<a class="headerlink" href="#general-parameter-shift-rule-with-the-lagrange-interpolation-approach" title="Permalink to this headline">¶</a></h2>
<p>The Lagrange interpolation is a calculus method that decomposes a quantum gate
in terms of the polynomials generator. It thus supports deriving the parameter-shift
rule with any generic generator. In this section, we derive the general parameter-
shift rule using the Lagrange interpolation and apply it to the first-order derivative
(gradient) for the cost function.</p>
</section>
<section id="lagrange-interpolation-approach">
<h2>3.1 Lagrange Interpolation Approach<a class="headerlink" href="#lagrange-interpolation-approach" title="Permalink to this headline">¶</a></h2>
<p>We begin with a general quantum gate represented by <span class="math notranslate nohighlight">\(U(x) = e^{−i\frac{x}{2} G\)</span>, where the Hermitian generator
G has n distinguished eigenvalues <span class="math notranslate nohighlight">\(\{ \lambda_k \}\)</span>, i.e., <span class="math notranslate nohighlight">\(G = \sum^{n−}_{k=0} \lambda_k |φ_k&gt;&lt;φ_k|\)</span>. The
Lagrange interpolation of the unitary U(x) is given by [14, 15]</p>
<div class="math notranslate nohighlight">
\[e^{− \frac{ x}{2} G} = \sum^{n−}_{k=0} e^{−i \frac{ x}{2} \lambda_k} \PI_{l=0,l \neq k}^{n-1} \frac{G -\]</div>
<p>lambda_lI}{lambda_k - lambda_l}</p>
<p>where I is an identity matrix having the same dimension as G. In the following, we
explicitly derive the general two-term, four-term, and multiple-term parameter-shift
rule from Eq. (5).</p>
</section>
<section id="two-term-parameter-shift-rule">
<h2>3.2 Two-Term Parameter-Shift Rule<a class="headerlink" href="#two-term-parameter-shift-rule" title="Permalink to this headline">¶</a></h2>
<p>We first consider case n = 2. Let λ0 and λ1 be two distinguished eigenvalues of G.
Equation (5) explicitly yields</p>
<p>e−i x
2 G = Λ0I + Λ1G, (6)</p>
<p>where</p>
<p>Λ0 = λ0e−i x
2 λ1 − λ1e−i x
2 λ0
λ0 − λ1
,</p>
<p>Λ1 = e−i x
2 λ0 − e−i x
2 λ1
λ0 − λ1
,</p>
<p>are the zero- and first-order coefficients of the Lagrange polynomial. Set a super-
operator</p>
<p>U(±α)[B] = U†(±α)BU(±α), (7)</p>
<p>which straightforwardly gives</p>
<p>U(α)[B] − U(−α)[B] = −2i sin( 1
2αλ)
λ
[
B, G]
, (8)</p>
<p>where λ = λ0 − λ1. Substituting Eq. (8) into Eq. (2), we obtain</p>
<p>∂
∂x
C(x) = λ
4 sin( 1
2αλ)
[
C(x + α) − C(x − α)]</p>
<p>. (9)</p>
<p>For example, let U(x) be a Pauli rotation gate, such as Rx (x) = e−i x
2 σx , Ry (x) = e−i x 2 σy , Rz(x) = e−i x2 σz , where G = {σx , σy , σz} are Pauli matrices. These generators have two eigenvalues as λ0 = −1, λ1 = 1. Then, Eq. (9) straightforwardly
deduces to Eq. (4). Besides these standard notations for superconducting-based
qubits, quantum computing with trapped ions uses spin-1/2 particle as a qubit. In
this case, a spin rotation gate is given in the terms of spin-1/2 operators, such as
Sx = σx /2, Sy = σy /2, Sz = σz/2. The derivative reads</p>
<p>∂
∂x
C(x) = 1
4 sin( 1
2α)
[
C(x + α) − C(x − α)]</p>
<p>. (10)</p>
<p>3.3 Four-Term Parameter-Shift Rule</p>
<p>For n = 3, i.e., G has three distinguished eigenvalues λ0, λ1, and λ2, we explicitly
recast Eq. (5) as [15]</p>
<p>e−i x
2 G = Λ0I + Λ1G + Λ2G2, (11)
Λ0 = −1
| |
{i,j }(λi − λj )
E
{k,l,m}
e−i x
2 λkλlλm(λl − λm),</p>
<p>Λ1 = 1
| |
{i,j }(λi − λj )
E
{k,l,m}
e−i x
2 λk (λ2
l − λ2
m),</p>
<p>Λ2 = E
2
k=0
e−i x
2 λk
| |
2
l=0,l/=k
1
λk − λl
,</p>
<p>where {i, j } takes{0, 1},{1, 2},{2, 0}, and {k,l,m} takes{0, 1, 2},{1, 2, 0},{2, 0, 1}.</p>
<p>Apply the super-operator U twice for the arbitrary shifts α1 and α2, we get the four-
term parameter-shift rule as</p>
<p>∂
∂x
C(x) = − i
2
{
d1
[
C(x + α1) − C(x − α1)
]</p>
<ul class="simple">
<li><p>d2</p></li>
</ul>
<p>[
C(x + α2) − C(x − α2)
]}
, (12)</p>
<p>where the coefficients d1,2 depend on the choice of α1,2.</p>
<p>For example, let U(x) be a controlled-rotation gate, where the eigenvalues of
G are λ0 = −1, λ1 = 0, λ2 = 1, which yields Λ0 = 1, Λ1 = −i sin(x/2), Λ2
= cos(x/2) − 1. Then, Eq. (11) explicitly gives</p>
<p>e−i x
2 G = I − i sin(x/2)G + [</p>
<p>cos(x/2) − 1
]
G2, (13)</p>
<p>which obeys the relation [9]:</p>
<p>d1 sin(α1/2) + d2 sin(α2/2) = 1
4
d1 sin(α1) + d2 sin(α2) = 1
2
.</p>
<ol class="arabic simple" start="14">
<li></li>
</ol>
<p>We can choose α1 = π/2 and α2 = π, then d1 = i and d2 = i(1 − √2)/2.</p>
<p>3.4 Multiple-Term Parameter-Shift Rule</p>
<p>For an arbitrary n &gt; 3, we have</p>
<p>e−i x
2 G = Λ0I + Λ1G +···+ Λn−1Gn−1, (15)</p>
<p>where all Λ terms are solvable. Explicitly, the super-operator U(α)[B] in Eq. (7)
yields</p>
<p>U(α)[B] = En−1
k,l=0
[
Λ∗
k (α)Λl(α)GkBGl
]
= Tr[
M(α) · FT]
, (16)</p>
<p>where the superscript T denotes the transpose, M(α) and F are (n × n)-matrices</p>
<p>M(α) =
⎛
⎜
⎜
⎜
⎝
Λ∗
0(α)Λ0(α) Λ∗</p>
<p>0(α)Λ1(α) ··· Λ∗
0(α)Λn−1(α)</p>
<p>Λ∗
1(α)Λ0(α) Λ∗</p>
<p>1(α)Λ1(α) ··· Λ∗
1(α)Λn−1(α)</p>
<section id="id3">
<h3>.<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>. .
.
. … .
.
.</p>
<p>Λ∗
n−1(α)Λ0(α) Λ∗</p>
<p>n−1(α)Λ1(α) ··· Λ∗</p>
<p>n−1(α)Λn−1(α)
⎞
⎟
⎟
⎟
⎠ , (17)</p>
<p>F =
⎛
⎜
⎜
⎜
⎝
G0BG0 G0BG1 ··· G0BGn−1
G1BG0 G1BG1 ··· G1BGn−1
.
.
. .
.
. … .
.
.
Gn−1BG0 Gn−1BG1 ··· Gn−1BGn−1
⎞
⎟
⎟
⎟
⎠ . (18)</p>
<p>We next compute</p>
<p>U(α)[B] − U(−α)[B] = Tr[(M(α) − M(−α))
· FT
]</p>
<p>= Tr[
ΔM(α) · FT]</p>
<p>. (19)</p>
<p>Notable that ΔM(α) is a complex symmetry matrix with diag[ΔM(α)] = 0 and
[ΔM(α)]ij = ([ΔM(α)]j i)∗. We set a column matrix D = (d1, d2, ··· , dm
)T that obeys</p>
<p>Em
k=1
dk
(
U(αk)[B] − U(−αk)[B]
)
= ℘[B, G]. (20)</p>
<p>Here, m depends on the number of non-vanish elements [ΔM(α)]ij , ∀j&gt;i, and ℘
is a coefficient similar as in Eq. (8)</p>
<p>℘ = Em
k=1
dk
[
ΔM(αk)
]
01 . (21)</p>
<p>We normalize dk by dk/℘. Finally, by substituting Eq. (20) into Eq. (2), we get the
multiple-term parameter-shift rule as</p>
<p>∂
∂x C(x) = − i
2
Em
k=1
dk
[
C(x + αk) − C(x − αk)
]
. (22)</p>
<p>Here, we need to compute m coefficients d1, ··· , dm regarding the shifts
α1, ··· , αm. See Algorithm 1 for the pseudo-code deriving all {dk} terms. For
the symmetry set of {λk}, we obtain m = L2n/4. − 1 for n ≥ 4. We summarize all
cases of m in Table 2.</p>
</section>
</section>
<section id="higher-order-derivative">
<h2>4 Higher-Order Derivative<a class="headerlink" href="#higher-order-derivative" title="Permalink to this headline">¶</a></h2>
<p>In this section, we compute higher-order derivatives of the cost function using the
parameter-shift rule. Let a variational circuit is governed by a set of quantum gates
U(θ) = V MUM(θM)··· V 1U1(θ1), (23)</p>
<p>where θ = (θ1, ··· , θM) is an M-tuple of classical parameters, and {V k} are
arbitrary constant gates. The derivative of an arbitrary order τ is defined by</p>
<p>∂τ
θ1,θ2,··· ,θτ C(θ) = ∂τ C(θ)
∂θ1∂θ2 ··· ∂θτ</p>
<p>. (24)</p>
<p>The first-order derivative of the cost function is given in the terms of parameter-
shift rule as in Eq. (22)</p>
<p>∂C(θ)
∂θj
= − i
2
Emj
k=1
dk
[
C(θ + αkej ) − C(θ − αkej )
]
, (25)</p>
<p>where ej is the unit vector along the θj axis. We next derive for higher-order
derivatives.</p>
<p>4.1 Second-Order Derivatives (Hessian)</p>
<p>The second-order derivative gives</p>
<p>∂2C(θ)
∂θj ∂θl
=
(−i
2
)2Emj
k=1
dk
{Eml
r=1
d
(α+
k )
r
[
C(α+
k + βrel) − C(α+
k − βr el)
]</p>
<p>− d
(α−
k )
r
[
C(α−
k + βrel) − C(α−
k − βrel)
]}
,
(26)</p>
<p>where α±
k = θ ± αkej .</p>
<p>For the two-term parameter shift rule, we have mj = ml = 1. From Eq. (9), if
λ = −2 (such as Pauli generators), then d1 = i/ sin(α1), and d
(α±1 ) 1 = i/ sin(β1).</p>
<p>The second-order derivative explicitly gives</p>
<p>∂2C(θ)
∂θj ∂θl
= 1
4 sin2(α)
[
C
(
θ + α(ej + el)
)
− C
(
θ + α(ej − el)
)</p>
<p>− C
(
θ − α(ej − el)
)
+ C
(
θ − α(ej + el)
)]
, (27)</p>
<p>where we used α1 = β1 = α.</p>
<p>For the four-term parameter shift rule, we have mj = ml = 2. Choosing α1 =
π/2 and α2 = π, then d1 = i and d2 = i(√2 − 1)/2. The second-order derivative
explicitly gives</p>
<p>∂2C(θ)
∂θj ∂θl
=
(−i
2
)2
{
− 1
[
C
(
θ + α1ej + α1el
)
− C
(
θ + α1ej − α1el
)]</p>
<p>− 1 − √2
2
[
C
(
θ + α1ej + α2el
)
− C
(
θ + α1ej − α2el
)]</p>
<ul class="simple">
<li></li>
</ul>
<p>[
C
(
θ − α1ej + α1el
)
− C
(
θ − α1ej − α1el
)]</p>
<ul class="simple">
<li></li>
</ul>
<p>1 − √2
2
[
C
(
θ − α1ej + α2el
)
− C
(
θ − α1ej − α2el
)]</p>
<p>− (1 − √2)
2
[
C
(
θ + α2ej + α1el
)
− C
(
θ + α2ej − α1el
)]</p>
<p>− (1 − √2)2
4
[
C
(
θ + α2ej + α2el
)
+ C
(
θ + α2ej − α2el
)]</p>
<ul class="simple">
<li><p>(1 − √2)</p></li>
</ul>
<p>θ − α2ej + α1el
)
− C
(
θ − α2ej − α1el
)]</p>
<ul class="simple">
<li><p>(1 − √2)2</p></li>
</ul>
<p>θ − α2ej + α2el
)
+ C
(
θ − α2ej − α2el
)]}
.
(28)</p>
<p>Similarly, one can extend the second-order derivatives for the general multiple-term
parameter-shift rule.</p>
<p>4.2 Fubini-Study Metric Tensor</p>
<p>We apply the above results to compute the Fubini-Study metric tensor. It is a
Riemannian metric that measures the “quantum distance” (in parameter spaces)
between the two quantum states. For pure quantum states, the metric tensor
associates with the Fisher information matrix or the Bures metric tensor [18].
Mathematically, for a pure state <a href="#id4"><span class="problematic" id="id5">|</span></a>ψ(θ)&gt; = U(θ)|ψ&gt;, the metric is defined in terms
of the second-order derivative as</p>
<p>gij (θ) = −1
2
∂2
∂θi∂θj
|
|
|
|
<a href="#id6"><span class="problematic" id="id7">|</span></a>&lt;ψ(θ’
)|ψ(θ)&gt;
|
|
2
|
|
|
θ’
=θ
. (29)</p>
<p>Here, the cost function is C(θ) = ||&lt;ψ(θ’)|ψ(θ)&gt;||2, which is the transition
probability from <a href="#id8"><span class="problematic" id="id9">|</span></a>ψ(θ)&gt; to <a href="#id10"><span class="problematic" id="id11">|</span></a>ψ(θ’)&gt;, under the action of U†(θ’)U(θ) on the initial
state <a href="#id12"><span class="problematic" id="id13">|</span></a>ψ&gt;. In other words, C(θ) is the probability of finding the outcome state <a href="#id14"><span class="problematic" id="id15">|</span></a>ψ&gt;
when measuring the final state <a href="#id16"><span class="problematic" id="id17">|</span></a>ψ(θ’, θ)&gt; = U†(θ’)U(θ)|ψ&gt;:</p>
<p>C(θ) ≡ p = |
<a href="#id18"><span class="problematic" id="id19">|</span></a>&lt;ψ(θ’
)|ψ(θ)&gt;
|
|
2</p>
<p>= |
<a href="#id20"><span class="problematic" id="id21">|</span></a>&lt;ψ|ψ(θ’
, θ)&gt;
|
|
2 (30)</p>
<p>where p is the probability of obtaining the outcome state <a href="#id22"><span class="problematic" id="id23">|</span></a>ψ&gt;. Notable that in
Eq. (29), we set θ’ = θ after the partial derivatives. However, in the quantum circuit
using the parameter-shift rule, we first apply U(θ ± shift) onto <a href="#id24"><span class="problematic" id="id25">|</span></a>ψ&gt; according with
Eqs. (27) and (28), then apply U†(θ), and measure the final circuit’s state.</p>
<p>Concretely, let us consider the example shown in Fig. 2. The circuit consists
of two qubits, which is initially prepared in the state <a href="#id26"><span class="problematic" id="id27">|</span></a>ψ&gt;=|00&gt;. The evaluation
operator U(θ) is parameterized by two single-qubit rotation gates Rx (θx ) and
Rz(θz), and a controlled-rotation gate CRy (θy ). Here, the parameters are given in
the order as θ = (θx , θz, θy). The state evolves to <a href="#id28"><span class="problematic" id="id29">|</span></a>ψ(θ)&gt; = U(θ)|00&gt;.</p>
<p>Conventionally, we can derive U(θ) into two layers: one with the two single-
qubit rotation gates and one with the controlled-rotation gate. Then, the Fubini-
Study is a tensor of (2×2)-matrix and (1×1)-matrix, i.e., becomes a (3×3)-matrix
[19]. Nevertheless, here we can directly apply the above method and get the same
result</p>
<p>⎛
⎝
gxx gxz gxy
gzx gzz gzy
gyx gyz gyy
⎞
⎠ =
⎛
⎝
1
4 0 0
00 0
0 0 1
4 sin2( θx
2 )
⎞
⎠ , (31)</p>
<p>where gjl, ∀j,l ∈ {x, z, y} are given in Eq. (29) and computed from the parameter-
shift rule as described in Eq. (30).</p>
</section>
<section id="numerical-simulations">
<h2>5 Numerical Simulations<a class="headerlink" href="#numerical-simulations" title="Permalink to this headline">¶</a></h2>
<p>In this section, we first revisit the finite-difference gradient and quantify the mean-
square error (MSE) as the figure of merit for evaluating different estimators (finite-
difference and parameter-shift rule estimators). We later demonstrate the numerical
evaluation of the MSE. Afterward, we also examine a variational quantum circuit to
find the ground state of a many-body system.</p>
<p>5.1 Finite-Difference Approximation of Derivatives</p>
<p>For a given step size h &gt; 0, the finite-difference gradient of a function f (θ) gives</p>
<p>∂f (θ)
∂θj
= f (θ + hej ) − f (θ − hej )</p>
<p>2h . (32)</p>
<p>The second-order derivatives is given via the Hessian formula [20]</p>
<p>∂f 2(θ)
∂xj ∂xl
= 1
4h2
[
f
(
θ + h(ej + el)
)
− f
(
θ + h(ej − el)
)</p>
<p>− f
(
θ − h(ej − el)
)
+ f
(
θ − h(ej + el)
)]
. (33)</p>
<p>These are approximate methods that give high accuracy when h → 0.</p>
<p>5.2 Mean-Square Error</p>
<p>Following Ref. [13], we consider the mean-square error (MSE) as the figure of merit
to evaluate the accuracy of different estimators. The MSE of an estimator&lt;∂τ
θ1,θ2,··· ,θτ is given as</p>
<p>Δ(&lt;∂τ
θ1,θ2,··· ,θτ ) = E
[ (
&lt;∂τ
θ1,θ2,··· ,θτ − ∂τ
θ1,θ2,··· ,θτ
)2 ]
, (34)</p>
<p>where ∂τ θ1,θ2,··· ,θτ is the analytical derivative equation (24), the estimator &lt;∂τ
θ1,θ2,··· ,θτ is either given by the parameter-shift rule or the finite-difference approximation.</p>
<p>5.3 Numerical Simulation the MSE</p>
<p>We investigate the precision of the two estimators based on the parameter-shift rule
and finite-difference approximation for the first-order derivatives. Let us consider
the example circuit shown in Fig. 2 and measure the expectation value &lt;Z ⊗ Z&gt; as</p>
<p>f (θ) = &lt;ψ(θ)|Z ⊗ Z|ψ(θ)&gt;
= 1
2
[
1 + cos(θx ) + (
cos(θx ) − 1
)
cos(θy )
]
. (35)</p>
<p>Analytically, we have</p>
<p>∇f (θ) =
⎛
⎝
∂θx f
∂θy f
∂θzf
⎞
⎠ =
⎛
⎜
⎝
− cos2 (
θy
2 )sin (θx )
sin2 ( θx
2 )sin (θy )
0
⎞
⎟
⎠ . (36)</p>
<p>For the finite-difference estimator, we compute the partial derivatives {&lt;∂θj f (θ)}
by using Eq. (32) and investigate the MSE (34) as a function of the step size h. For
the parameter-shift estimator, &lt;∂θx f (θ) and &lt;∂θzf (θ) are given by the two-term (9)
while&lt;∂θy f (θ) is given by the four-term (12). We choose the shift α of the two-term
the same as step size h and fix the four-term coefficients as above. The simulation
runs in Qiskit’s Aer simulator, and the expectation values are given after 103 shots,
and other 103 repetitions are used to determine the average of the MSE.</p>
<p>The results are shown in the main Fig. 3. The MSE for the parameter-shift
estimator gradually reduces and saturates at the optimal value when increasing
the step size. Similarly, the finite-difference curve reduces, then matches with the
parameter-shift curve, and finally deviates from the expected behavior since the
Taylor expansion is no longer viable for large step sizes [13]. For small step sizes,
the two estimators do not coincide because their &lt;∂θy f (θ) are different, i.e., one is
varied with h, and one is fixed. Details are shown in the inset Fig. 3.</p>
<p>5.4 Variational Quantum Eigensolver</p>
<p>In this subsection, we demonstrate our approach in the variational quantum
eigensolver (VQE) to find the ground state of a given system. We consider the
Lipkin-Meshkov-Glick (LMG) model [21] consisting of N spin-1/2 particles with
infinite-range interaction and exposing under a magnetic field along the z axis, as
shown in Fig. 4a. The interaction Hamiltonian is given by</p>
<p>Fig. 3 Log-log plot of the mean-square error (MSE) versus the step size h for two estimators
parameter-shift and finite-difference. The shaded areas show the standard deviation, and the solid
lines represent the average MSE over 103 repetitions. For each MSE, we perform 103 shots to
compute the expectation value. Insets: the plot of MSE for partial differences&lt;∂θx f (θ) and&lt;∂θy f (θ)</p>
<p>Fig. 4 (a) The LMG model with N spin-1/2 particles that obeys the infinite-range interaction and
is placed under the magnetic field along the z axis. (b) The learning circuit used in VQE consists
of (RX − RZ − RX)×L gates. The expectation value &lt;H&gt; is measured and be the cost function.
(c) The cost function versus iterations for γ = 0, −0.05, −0.1 and the theoretical bounds are
{−0.10583, −0.269744, −0.509973}, respectively. (d) The minimum energy for γ from −0.1 to
0.1. The solid curve is the exact result from theoretical analysis by diagonalizing the Hamiltonian
(37), and the dotted curve is obtained from the generalize parameter-shift rule</p>
<p>H = −2γ Jz − 2λ
N
(
J 2
x − J 2
y
)
, (37)</p>
<p>where γ is an effective magnetic field, λ is the spin-spin exchange coupling, and
Jk, (k = x, y, z) is a collective angular momentum</p>
<p>Jk = 1
2
E
N
l=1
I ⊗···⊗ σ(l)
k ⊗···⊗ I , (38)</p>
<p>where σ(l) k is a Pauli matrix at the site l. The purpose is to find the ground state of
the Hamiltonian (37) by using the VQE and compare it with the theoretical result.</p>
<p>The learning circuit is shown in Fig. 4b with the initial state is ρ = q1 ⊗ q2 ⊗
···⊗ qN . The training ansatz U(θ) reads</p>
<p>U(θ) = (
RX(θ3)RZ(θ2)RX(θ1)</p>
<p>)×L, (39)</p>
<p>with several layers L. Here, RX and RZ are collective rotation gates [17] that
are sufficient to generate any quantum state in the Bloch sphere, and θ = (
θ1, θ2, θ3, ··· , θ3L)
are training parameters. The quantum state evolves to ρ(θ) =
U(θ)ρU†(θ) under the action of U(θ). Finally, we measure the expectation value
of the Hamiltonian and define the cost function as</p>
<p>C(θ) = &lt;H&gt; = Tr[
H · ρ(θ)
]
, (40)</p>
<p>from which its minimum value is the lowest energy, and the corresponding state
ρ(θ) becomes the ground state.</p>
<p>The simulation is executed in the tqix code [17]. Here we fit N = 5, L = 5
layers, and λ = 0.05. We also add random noises in every quantum gates. We train
the model in 30 iterations with the standard gradient descent (SGD) optimizer</p>
<p>θ(t+1) = θ(t) − η∇θC(θ), (41)</p>
<p>where learning rate is η = 0.4, and ∇θC(θ) is calculated via the generalize
parameter-shift rule (see detailed in the Appendix).</p>
<p>Figure 4c displays the cost function versus the number of iterations, where
it moves toward the theoretical bound after a certain number of iterations. The
minimum energy given by the VQE and a comparison with the theoretical result
are shown in Fig. 4d. The plots are given for different γ from -0.1 to +0.1, offering
an excellent match between these two approaches.</p>
<p>6 Conclusion</p>
<p>We introduced the Lagrange interpolation approach for the general parameter-shift
rule. This method is based on the interpolation of any given quantum gate into
a polynomial form of its generator. We thus derived the general multiple-term
parameter-shift rule and the higher-order derivative. We provided the numerical
benchmarking via the mean-square error and further applied to the variational
quantum eigensolver. Our approach can apply to various collective rotation gates
in spin ensemble-based quantum computers.
The code is available in <a class="reference external" href="https://github.com/vutuanhai237/LagrangeGPSR">https://github.com/vutuanhai237/LagrangeGPSR</a>.</p>
<p>Appendix</p>
<p>Generalized Parameter-Shift Rule for VQE</p>
<p>We compute the generalized parameter-shift rule for two quantum gates RX and
RZ in the circuit Fig. 4b. They read</p>
<p>RX(x) = e−ixJx , and RZ(x) = e−ixJz . (42)</p>
<p>Since both Jx and Jz have the same eigenvalues, hereafter, we derive for RZ
while RX can be done the same. The eigenvalues of Jz for N = 5 include
λ = {−5/2, −3/2, −1/2, 1/2, 3/2, 5/2}. Hence, n = 6 and m = L2n/4. − 1 = 15.
Apply Algorithms 1 with random {αk}15k=1 ∈ [0, 2π], we find the corresponding
{dk}. The derivatives associated RZ is given from Eq. (22) as</p>
<p>∂
∂x RZ(x) = −i
E
15
k=1
dk
[
RZ(x + αk) − RZ(x − αk)
]
. (43)</p>
<p>Note that here we replace −i/2 from Eq. (22) by −i because RZ contains parameter
x instead of x/2. Doing similarly for RX, and finally, we obtain ∂θ &lt;H&gt;.</p>
<p>References</p>
<ol class="arabic simple">
<li><ol class="upperalpha simple" start="10">
<li><ol class="upperalpha simple" start="4">
<li><p>Hidary, Quantum Computing: An Applied Approach, Springer Cham, 2019.</p></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>2. Y. Alexeev, D. Bacon, K. R. Brown, R. Calderbank, L. D. Carr, F. T. Chong, B. DeMarco,
D. Englund, E. Farhi, B. Fefferman, A. V. Gorshkov, A. Houck, J. Kim, S. Kimmel, M. Lange,
S. Lloyd, M. D. Lukin, D. Maslov, P. Maunz, C. Monroe, J. Preskill, M. Roetteler, M. J.
Savage, J. Thompson, Quantum computer systems for scientific discovery, PRX Quantum 2
(2021) 017001. doi:10.1103/PRXQuantum.2.017001. URL https://link.aps.org/doi/10.1103/
PRXQuantum.2.017001</p>
<p>3. J. Preskill, Quantum Computing in the NISQ era and beyond, Quantum 2 (2018) 79.
doi:10.22331/q-2018-08-06-79. URL https://doi.org/10.22331/q-2018-08-06-79</p>
<p>4. M. Cerezo, A. Arrasmith, R. Babbush, S. C. Benjamin, S. Endo, K. Fujii, J. R. McClean,
K. Mitarai, X. Yuan, L. Cincio, P. J. Coles, Variational quantum algorithms, Nature Reviews
Physics 3 (9) (2021) 625–644. doi:10.1038/s42254-021-00348-9. URL https://doi.org/10.
1038/s42254-021-00348-9</p>
<p>5. K. Mitarai, M. Negoro, M. Kitagawa, K. Fujii, Quantum circuit learning, Phys. Rev. A
98 (2018) 032309. doi:10.1103/PhysRevA.98.032309. URL https://link.aps.org/doi/10.1103/
PhysRevA.98.032309</p>
<p>6. M. Schuld, V. Bergholm, C. Gogolin, J. Izaac, N. Killoran, Evaluating analytic gradients on
quantum hardware, Phys. Rev. A 99 (2019) 032331. doi:10.1103/PhysRevA.99.032331. URL
https://link.aps.org/doi/10.1103/PhysRevA.99.032331</p>
<ol class="arabic simple" start="7">
<li><ol class="upperalpha simple" start="3">
<li><ol class="upperalpha simple" start="16">
<li><p>Williams, Explorations in Quantum Computing, Springer London, 2011.</p></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>8. M. A. Nielsen, I. L. Chuang, Quantum Computation and Quantum Information, Cambridge,
2010.</p>
<p>9. G.-L. R. Anselmetti, D. Wierichs, C. Gogolin, R. M. Parrish, Local, expressive, quantum-num-
ber-preserving VQE ansätze for fermionic systems, New Journal of Physics 23 (11) (2021)
113010. doi:10.1088/1367-2630/ac2cb3. URL https://doi.org/10.1088/1367-2630/ac2cb3</p>
<p>10. D. Wierichs, J. Izaac, C. Wang, C. Y.-Y. Lin, General parameter-shift rules for quantum
gradients, Quantum 6 (2022) 677. doi:10.22331/q-2022-03-30-677. URL https://doi.org/10.
22331/q-2022-03-30-677</p>
<p>11. O. Kyriienko, V. E. Elfving, Generalized quantum circuit differentiation rules, Phys. Rev.
A 104 (2021) 052417. doi:10.1103/PhysRevA.104.052417. URL https://link.aps.org/doi/10.
1103/PhysRevA.104.052417</p>
<p>12. A. F. Izmaylov, R. A. Lang, T.-C. Yen, Analytic gradients in variational quantum algorithms:
Algebraic extensions of the parameter-shift rule to general unitary transformations, Phys. Rev.
A 104 (2021) 062443. doi:10.1103/PhysRevA.104.062443. URL https://link.aps.org/doi/10.
1103/PhysRevA.104.062443</p>
<p>13. A. Mari, T. R. Bromley, N. Killoran, Estimating the gradient and higher-order derivatives on
quantum hardware, Phys. Rev. A 103 (2021) 012405. doi:10.1103/PhysRevA.103.012405.
URL https://link.aps.org/doi/10.1103/PhysRevA.103.012405</p>
<p>14. C. Moler, C. Van Loan, Nineteen dubious ways to compute the exponential of a matrix, SIAM
Review 20 (4) (1978) 801–836. arXiv:https://doi.org/10.1137/1020098, doi:10.1137/1020098.
URL https://doi.org/10.1137/1020098</p>
<p>15. L. B. Ho, N. Imoto, Full characterization of modular values for finite-dimensional systems,
Physics Letters A 380 (25) (2016) 2129–2135. doi:https://doi.org/10.1016/j.physleta.2016.05.
005. URL https://www.sciencedirect.com/science/article/pii/S0375960116301773</p>
<p>16. S. Debnath, N. M. Linke, C. Figgatt, K. A. Landsman, K. Wright, C. Monroe, Demonstration
of a small programmable quantum computer with atomic qubits, Nature 536 (7614) (2016)
63–66. doi:10.1038/nature18648. URL https://doi.org/10.1038/nature18648</p>
<p>17. N. T. Viet, N. T. Chuong, V. T. N. Huyen, L. B. Ho, tqix.pis: A toolbox for quantum dynamics
simulation of spin ensembles in dicke basis, Computer Physics Communications 286 (2023)
108686. doi:https://doi.org/10.1016/j.cpc.2023.108686. URL https://www.sciencedirect.com/
science/article/pii/S0010465523000310</p>
<p>18. J. Liu, H. Yuan, X.-M. Lu, X. Wang, Quantum fisher information matrix and multiparameter
estimation, Journal of Physics A: Mathematical and Theoretical 53 (2) (2019) 023001.
doi:10.1088/1751-8121/ab5d4d. URL https://doi.org/10.1088/1751-8121/ab5d4d</p>
<p>19. V. T. Hai, L. B. Ho, Universal compilation for quantum state tomography, Scientific Reports
13 (1) (2023) 3750. doi:10.1038/s41598-023-30983-4. URL https://doi.org/10.1038/s41598-
023-30983-4</p>
<p>20. I. A. S. Milton Abramowitz, Handbook of Mathematical Functions: with Formulas, Graphs,
and Mathematical Tables, Courier Corporation, 1965.</p>
<p>21. H. Lipkin, N. Meshkov, A. Glick, Validity of many-body approximation methods for a solvable
model: (i). exact solutions and perturbation theory, Nuclear Physics 62 (2) (1965) 188–
198. doi:https://doi.org/10.1016/0029-5582(65)90862-X. URL https://www.sciencedirect.
com/science/article/pii/002955826590862X</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Calculo</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Introductor_Statistics_with_R_2E</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Introductor_Statistics_with_R_2E/index2.html">Introductor_Statistics_with_R_2E</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Geometria_Trigonometria</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Geometria_Trigonometria/c02.html">c02 Angulos</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Temarios</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Temarios/index2.html">Temarios</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">A_First_Course_Design_Analysis_Experiments_Gary</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../A_First_Course_Design_Analysis_Experiments_Gary/index2.html">A_First_Course_Design_Analysis_Experiments_Gary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">An_Introduction_Dynmical_Systems_Chaos_2E</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../An_Introduction_Dynmical_Systems_Chaos_2E/index2.html">A_First_Course_Design_Analysis_Experiments_Gary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../calculo_diferencial_integral/index2.html">A_First_Course_Design_Analysis_Experiments_Gary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Statistical_Research_Methods_Roy/index2.html">A_First_Course_Design_Analysis_Experiments_Gary</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lagrange Interpolation Approach for General Parameter-Shift Rule</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#preliminary">2 Preliminary</a></li>
<li class="toctree-l2"><a class="reference internal" href="#general-parameter-shift-rule-with-the-lagrange-interpolation-approach">3 General Parameter-Shift Rule with the Lagrange Interpolation Approach</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lagrange-interpolation-approach">3.1 Lagrange Interpolation Approach</a></li>
<li class="toctree-l2"><a class="reference internal" href="#two-term-parameter-shift-rule">3.2 Two-Term Parameter-Shift Rule</a></li>
<li class="toctree-l2"><a class="reference internal" href="#higher-order-derivative">4 Higher-Order Derivative</a></li>
<li class="toctree-l2"><a class="reference internal" href="#numerical-simulations">5 Numerical Simulations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Applied_Delay_Differential_Equations/index2.html">Applied_Delay_Differential_Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../The_Essential_Guide_to_HTML5_3E_Jeanine/index2.html">The_Essential_Guide_to_HTML5_3E_Jeanine</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index2.html">&lt;no title&gt;</a><ul>
      <li>Previous: <a href="index2.html" title="previous chapter">&lt;no title&gt;</a></li>
      <li>Next: <a href="../Applied_Delay_Differential_Equations/index2.html" title="next chapter">Applied_Delay_Differential_Equations</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, santosg57.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/Quantum_Computing_Himanshu/Quantum_Computing_Himanshu_c01.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>